import { ChildDocs } from "docs-ui"

export const metadata = {
  title: `Database Access in Medusa v2`,
}

# {metadata.title}

If you've upgraded to Medusa v2 and are trying to access the database, you might have noticed that the previous import path no longer works:

```ts
// ❌ This no longer works in v2
import { dataSource } from "@medusajs/medusa/loaders/database"
```

This is because Medusa v2 has migrated from TypeORM to MikroORM, changing how database access is structured. This guide explains the new approaches for database operations in v2.

## How to Access the Database

There are several ways to work with the database in Medusa v2:

### Option 1: Create a Custom Repository

The recommended approach is to create a custom repository for your entity:

```ts
import { DALUtils } from "@medusajs/framework/utils"
import { Product } from "./models/product"

export class ProductRepository extends DALUtils.mikroOrmBaseRepositoryFactory(Product) {
  // Add custom methods for specialized queries
  async findAvailableProducts() {
    return await this.find({
      where: { status: "published", inventory_quantity: { $gt: 0 } }
    })
  }
}
```

Register it in your module's loader:

```ts
import { asClass } from "awilix"
import { ProductRepository } from "./repositories/product-repository"

export default async ({ container }) => {
  container.register({
    productRepository: asClass(ProductRepository).singleton(),
  })
}
```

### Option 2: Inject the Entity Manager

You can inject the entity manager directly into your services:

```ts
import { MedusaService } from "@medusajs/framework/utils"
import { Product } from "./models/product"

export class ProductService extends MedusaService {
  protected readonly manager_
  
  constructor({ manager }) {
    super()
    this.manager_ = manager
  }
  
  async findProducts(filters = {}) {
    return await this.manager_.find(Product, {
      where: filters
    })
  }
}
```

### Option 3: Run Raw SQL Queries

For complex queries or performance-critical operations, you can run raw SQL:

```ts
async function getProductStats() {
  const knex = this.manager_.getKnex()
  
  return await knex.raw(`
    SELECT 
      category_id, 
      COUNT(*) as product_count, 
      AVG(price) as average_price 
    FROM products 
    GROUP BY category_id
  `)
}
```

## Common Database Operations

Here are examples of typical operations using a repository:

```ts
// Create a new product
const product = await productRepository.create({
  title: "Ergonomic Chair",
  description: "Office chair with lumbar support",
  price: 299.99,
  inventory_quantity: 50
})

// Find a specific product
const product = await productRepository.findOne({
  where: { id: "prod_123456789" }
})

// Update a product
await productRepository.update("prod_123456789", {
  inventory_quantity: 42,
  metadata: {
    featured: true
  }
})

// Delete a product
await productRepository.delete("prod_123456789")
```

## Transactions

To ensure database consistency across multiple operations:

```ts
await productRepository.transaction(async (transactionManager) => {
  // Create a new product
  const product = transactionManager.create(Product, {
    title: "Limited Edition Watch",
    price: 1299.99
  })
  
  // Update inventory in the same transaction
  const inventory = transactionManager.findOne(Inventory, {
    where: { sku: "WATCH-LE-2023" }
  })
  
  inventory.quantity = inventory.quantity - 1
  
  // Save both changes atomically
  await transactionManager.persistAndFlush([product, inventory])
  
  return product
})
```

These approaches will help you work effectively with the database in Medusa v2 while taking advantage of MikroORM's powerful features. 
