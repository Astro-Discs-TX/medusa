---
description: 'Learn how to create endpoints in Medusa. This guide also includes how to add CORS configurations, creating multiple endpoints, adding protected routes, and more.'
addHowToData: true
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# How to Create Endpoints

In this document, youâ€™ll learn how to create endpoints in Medusa.

:::tip

v1.17.2 of `@medusajs/medusa` introduced a new approach to creating custom endpoints based on file-routes. You can still use the [Express Router Approach](./create-express-route.mdx), however, it's highly recommended that you start using this new approach.

:::

## Basic Implementation

```ts title=src/api/store/custom/route.ts
import type { 
  MedusaRequest, 
  MedusaResponse,
} from "@medusajs/medusa"

export const GET = (
  req: MedusaRequest,
  res: MedusaResponse
) => {
  res.json({
    message: "[GET] Hello world!",
  })
}

export const POST = (
  req: MedusaRequest, 
  res: MedusaResponse
) => {
  res.json({
    message: "[POST] Hello world!",
  })
}
```

### Endpoint Paths

Custom endpoints must be created in a file named `route.ts` or `route.js` under the `src/api` directory of your Medusa backend or plugin. The endpoint's path will be the same as the path of its corresponding `route.ts` file relative to `src/api`.

For example, if you're creating the route `store/custom`, you must create the file `src/api/store/custom/route.ts`.

### Endpoint Methods

`route.ts` can export at least one of the following functions: `GET`, `POST`, `DELETE`, `PUT`, `PATCH`, `OPTIONS`, and `HEAD`. Defining these functions adds a new endpoint for the corresponding HTTP method at the same path.

Each of these functions receives two parameters: the `MedusaRequest` which extends Express's [Request](https://expressjs.com/en/api.html#req), and the `MedusaResponse` which extends [Response](https://expressjs.com/en/api.html#res). Both are imported from `@medusajs/medusa`.

In the example above, `GET` and `POST` endpoints will be added at the `store/custom` route.

---

## Building Files

Custom endpoints must be transpiled and moved to the `dist` directory before you can start consuming them. When you run your backend using either the `medusa develop` or `npx medusa develop` commands, it watches the files under `src` for any changes, then triggers the `build` command and restarts the server.

However, the build isn't triggered when the backend first starts running, and it's never triggered when the `medusa start` or `npx medusa start` commands are used.

So, make sure to run the `build` command before starting the backend and testing out your endpoint:

```bash npm2yarn
npm run build
```

---

## Medusa Endpoint Path Convention

Although your endpoint can be under any path you wish, the Medusa backend uses the following conventions:

- All storefront REST APIs are prefixed by `/store`. For example, the `/store/products` endpoint lets you retrieve the products to display them on your storefront.
- All admin REST APIs are prefixed by `/admin`. For example, the `/admin/products` endpoint lets you retrieve the products to display them on your admin.

---

## Path Parameters

If your endpoint accepts a path parameter, you can place its route file inside a directory with the name `[<PARAMETER_NAME>]`, where `<PARAMETER_NAME>` is the name of your parameter.

For example, to add an endpoint at the path `store/custom/[id]`, create the route file at `src/api/store/custom/[id]/route.ts`.

Path parameters are accessed using `req.params`. For example:

```ts title=src/api/store/custom/[id]/route.ts
import type { 
  MedusaRequest, 
  MedusaResponse,
} from "@medusajs/medusa"

export function GET(
  req: MedusaRequest,
  res: MedusaResponse
) {
  const id = req.params.id

  // do something with the ID.
}
```

An endpoint can have more than one path parameter, but each path parameter is unique. If the same path parameter is used more than once in the same route path, it results in an error and the endpoint will not be registered.

For example, if your route accepts an author ID and a post ID, your endpoint path can be `src/api/author/[id]/posts/[post_id]/route.ts`. You can then use `req.params.id` and `req.params.post_id` to access the path parameters.

---

## CORS Configuration

CORS configurations are automatically added to custom routes defined under the `/store` or `/admin` route prefixes based on the [store_cors and admin_cors configurations](../backend/configurations.md#admin_cors-and-store_cors) respectively. This section is useful if you're defining a route under a different prefix, or you want to override the defined CORS confiurations.

To add or override the CORS configurations, define a [middleware](./add-middleware.mdx) on your routes and pass it the `cors` middleware. For example:

```ts title=src/api/middlewares.ts
import type { 
  MiddlewaresConfig,
} from "@medusajs/medusa"
import cors from "cors"

export const config: MiddlewaresConfig = {
  routes: [
    {
      matcher: "/custom/*",
      middlewares: [
        cors({
          origin: "*",
          credentials: true,
        }),
      ],
    },
  ],
}
```

---

## Parse Request Body Parameters

By default, all requests with the `Content-Type` header set to `application/json` are parsed using [Express's json middleware](https://expressjs.com/en/api.html#express.json). You can access the request body parameters using the `req.body` method.

For example:

```ts title=src/api/store/custom/route.ts
import type { 
  MedusaRequest, 
  MedusaResponse,
} from "@medusajs/medusa"

export const POST = (
  req: MedusaRequest,
  res: MedusaResponse
) => {
  const name = req.body.name

  // do something with the data...
}
```

If you want to parse other content types, such as `application/x-www-form-urlencoded`, you have to pass the middleware in the list of the routes' [middlewares](./add-middleware.mdx). For example:

```ts title=src/api/middlewares.ts
import type { 
  MiddlewaresConfig,
} from "@medusajs/medusa"
import { 
  urlencoded,
} from "body-parser"

export const config: MiddlewaresConfig = {
  routes: [
    {
      matcher: "/store/*",
      middlewares: [
        urlencoded({ extended: true }),
      ],
    },
  ],
}
```

You can then access urlencoded payloads using `req.body` as well.

---

## Protected Routes

Protected routes are routes that should only be accessible by logged-in customers or users.

### Protect Store Routes

There are two approaches to make a storefront route protected:

- Using the `requireCustomerAuthentication` middleware, which disallows unauthenticated customers from accessing a route, and allows you to access the logged-in customer's ID.
- Using the `authenticateCustomer` middleware, which allows both authenticated and unauthenticated customers to access your route, but allows you to access the logged-in customer's ID as well.

To make a storefront route(s) protected using either middlewares, pass the middleware in the list of the route's [middlewares](./add-middleware.mdx). For example:

```ts title=src/api/middlewares.ts
import type { MiddlewaresConfig } from "@medusajs/medusa"
import { 
  requireCustomerAuthentication,
} from "@medusajs/medusa"
// import { authenticateCustomer } from "@medusajs/medusa"

export const config: MiddlewaresConfig = {
  routes: [
    {
      matcher: "/store/*",
      middlewares: [
        requireCustomerAuthentication(),
        // authenticateCustomer()
      ],
    },
  ],
}
```

You can then access the customer's ID using `req.user.customer_id`. Note that if you're using the `authenticateCustomer` middleware, `req.user.customer_id` may be undefined.

For example:

```ts title=src/api/store/custom/route.ts
import { CustomerService } from "@medusajs/medusa"
import type { 
  MedusaRequest, 
  MedusaResponse,
} from "@medusajs/medusa"

export const GET = async (
  req: MedusaRequest,
  res: MedusaResponse
) => {
  const id = req.user.customer_id
  // if you're using authenticateCustomer middleware
  // check if id is set first

  const customerService = req.scope.resolve<CustomerService>(
    "customerService"
  )
      
  const customer = await customerService.retrieve(id)

  // ...
}
```

### Protect Admin Routes

By default, all routes prefixed by `/admin` require authentication.

If you want to disable authentication on an admin route, export a `AUTHENTICATE` variable in your route file with its value set to `false`.

For example:

```ts title=src/api/admin/custom/route.ts
import type { 
  MedusaRequest, 
  MedusaResponse,
} from "@medusajs/medusa"

export const GET = async (
  req: MedusaRequest,
  res: MedusaResponse
) => {
  res.json({
    message: "Hello",
  })
}

export const AUTHENTICATE = false
```

---

## Retrieve Medusa Config

You can access the configurations exported in `medusa-config.js`, including your custom configurations, by resolving the `configModule` resource using [dependency injection](../fundamentals/dependency-injection.md).

For example:

```ts title=src/api/store/custom/route.ts
import type { 
  MedusaRequest,
  MedusaResponse,
} from "@medusajs/medusa"
import { ConfigModule } from "@medusajs/medusa"

// This is only helpful if you're 
// accessing custom configurations
// otherwise it's fine to just use `ConfigModule`
type MyConfigModule = ConfigModule & {
  projectConfig: {
    custom_config?: string
  }
}

export const GET = (
  req: MedusaRequest,
  res: MedusaResponse
) => {
  const configModule = req.scope.resolve<MyConfigModule>(
    "configModule"
  )
  res.json({
    message: configModule.projectConfig.custom_config,
  })
}
```

---

## Use Other Resources

### Entities and Repositories

Your endpoints likely perform an action on an entity. For example, you may create an endpoint to retrieve a list of posts.

You can perform actions on an entity either through its [Repository](../entities/overview.mdx#what-are-repositories) or through a [service](#services). This section covers how to retrieve a repository in an endpoint, but it's recommended to use services instead.

You can retrieve any registered resource, including repositories, in your endpoint using `req.scope.resolve` passing it the resource's registration name in the [dependency container](../fundamentals/dependency-injection.md). Repositories are registered as their camel-case name. So, for example, if you have a `PostRepository`, it's registered as `postRepository`.

Hereâ€™s an example of an endpoint that retrieves the list of posts in a store:

:::note

Posts are represented by a custom entity not covered in this guide. You can refer to the [entities](../entities/create.mdx#adding-relations) for more details on how to create a custom entity.

:::

```ts title=src/api/store/posts/route.ts
import type { 
  MedusaRequest, 
  MedusaResponse,
} from "@medusajs/medusa"
import { 
  PostRepository,
} from "../../../repositories/post"
import { EntityManager } from "typeorm"

export const GET = async (
  req: MedusaRequest, 
  res: MedusaResponse
) => {
  const postRepository = 
    req.scope.resolve<PostRepository>("postRepository")
  const manager = req.scope.resolve<EntityManager>("manager")
  const postRepo = manager.withRepository(postRepository)

  res.json({
    posts: await postRepo.find(),
  })
}
```

Notice that to retrieve an instance of the repository, you need to retrieve first Typeorm's Entity manager and use its `withRepository` method.

### Services

You can retrieve [services](../services/create-service.mdx) in your endpoint using `req.scope.resolve` passing it the serviceâ€™s registration name in the [dependency container](../fundamentals/dependency-injection.md). Services are registered as their camel-case name. So, for example, if you have a `PostService`, it's registered as `postService`.

Hereâ€™s an example of an endpoint that retrieves the list of posts in a store:

:::note

`PostService` is a custom service that is not covered in this guide. You can refer to the [services](../services/create-service.mdx) documentation for more details on how to create a custom service, and find an [example of PostService](../services/create-service.mdx#example-services-with-crud-operations)

:::

```ts title=src/api/store/posts/route.ts
import type { 
  MedusaRequest, 
  MedusaResponse,
} from "@medusajs/medusa"
import { PostService } from "../../../services/post"

export const GET = async (
  req: MedusaRequest, 
  res: MedusaResponse
) => {
  const postService: PostService = req.scope.resolve(
    "postService"
  )

  res.json({
    posts: await postService.list(),
  })
}
```

### Other Resources

Any resource that's registered in the dependency container, such as strategies or file services, can be accessed through `req.scope.resolve`. Refer to the [dependency injection](../fundamentals/dependency-injection.md) documentation for details on registered resources.

---

## Example: CRUD Endpoints

This section services as an example of creating endpoints that perform Create, Read, Update, and Delete (CRUD) operations.

:::note

You can refer to the [Entities](../entities/create.mdx#adding-relations) and [Services](../services/create-service.mdx#example-services-with-crud-operations) documentation to learn how to create the custom entities and services used in this example.

:::

<Tabs groupId="files" isCodeTabs={true}>
<TabItem value="posts-routes" label="src/api/admin/posts/route.ts" default>

```ts
import type { 
  MedusaRequest, 
  MedusaResponse,
} from "@medusajs/medusa"
import { PostService } from "../../../services/post"

// list posts
export const GET = async (
  req: MedusaRequest, 
  res: MedusaResponse
) => {
  const postService: PostService = req.scope.resolve(
    "postService"
  )

  res.json({
    posts: await postService.list(),
  })
}

// create a post
export const POST = async (
  req: MedusaRequest, 
  res: MedusaResponse
) => {
  const postService: PostService = req.scope.resolve(
    "postService"
  )

  // basic validation of request body
  if (!req.body.title || !req.body.author_id) {
    throw new Error("`title` and `author_id` are required.")
  }

  const post = await postService.create(req.body)

  res.json({
    post,
  })
}
```

</TabItem>
<TabItem value="posts-id-routes" label="src/api/admin/posts/[id]/route.ts">

```ts
import type { 
  MedusaRequest, 
  MedusaResponse,
} from "@medusajs/medusa"
import { PostService } from "../../../services/post"

// retrieve a post by its ID
export const GET = async (
  req: MedusaRequest, 
  res: MedusaResponse
) => {
  const postService: PostService = req.scope.resolve(
    "postService"
  )

  const post = await postService.retrieve(req.params.id)

  res.json({
    post,
  })
}

// update a post by its ID
export const POST = async (
  req: MedusaRequest, 
  res: MedusaResponse
) => {
  const postService: PostService = req.scope.resolve(
    "postService"
  )

  // basic validation of request body
  if (req.body.id) {
    throw new Error("Can't update post ID")
  }

  const post = await postService.update(
    req.params.id,
    req.body
  )

  res.json({
    post,
  })
}

// delete a post by its ID
export const DELETE = async (
  req: MedusaRequest, 
  res: MedusaResponse
) => {
  const postService: PostService = req.scope.resolve(
    "postService"
  )

  await postService.delete(req.params.id)

  res.status(200).end()
}
```

</TabItem>
</Tabs>

---

## See Also

- [Storefront API Reference](https://docs.medusajs.com/api/store)
- [Admin API Reference](https://docs.medusajs.com/api/admin)
