export const metadata = {
  title: `${pageNumber} Migrations`,
}

# {metadata.title}

In this chapter, you'll learn what a migration is and how to generate a migration or write it manually.

## What is a Migration?

A migration is a TypeScript or JavaScript file that defines database changes made by a module. Migrations are useful when you re-use a module or you're working in a team, so that when one member of a team makes a database change, everyone else can reflect it on their side by running the migrations.

The migration's file has a class with two methods:

- The `up` method reflects changes on the database.
- The `down` method reverts the changes made in the `up` method.

---

## Generate Migration

Instead of you writing the migration manually, the Medusa CLI tool provides a [db:generate](!resources!/medusa-cli/commands/db#dbgenerate) command to generate a migration for a modules' data models.

For example, assuming you have a `blog` Module, you can generate a migration for it by running the following command:

```bash
npx medusa db:generate blog
```

This generates a migration file under the `migrations` directory of the Blog Module. You can then run it to reflect the changes in the database as mentioned in [this section](#run-the-migration).

---

## Write a Migration Manually

You can also write migrations manually. To do that, create a file in the `migrations` directory of the module and in it, a class that has an `up` and `down` method. The class's name should be of the format `Migration{YEAR}{MONTH}{DAY}{HOUR}{MINUTE}.ts` to ensure migrations are ran in the correct order.

For example:

```ts title="src/modules/blog/migrations/Migration202507021059.ts"
import { Migration } from "@mikro-orm/migrations"

export class Migration202507021059 extends Migration {

  async up(): Promise<void> {
    this.addSql("create table if not exists \"author\" (\"id\" text not null, \"name\" text not null, \"created_at\" timestamptz not null default now(), \"updated_at\" timestamptz not null default now(), \"deleted_at\" timestamptz null, constraint \"author_pkey\" primary key (\"id\"));")
  }

  async down(): Promise<void> {
    this.addSql("drop table if exists \"author\" cascade;")
  }

}
```

The migration class in the file extends the `Migration` class imported from `@mikro-orm/migrations`. In the `up` and `down` method of the migration class, you use the `addSql` method provided by MikroORM's `Migration` class to run PostgreSQL syntax.

In the example above, the `up` method creates the table `author`, and the `down` method drops the table if the migration is reverted.

<Note title="Tip">

Refer to [MikroORM's documentation](https://mikro-orm.io/docs/migrations#migration-class) for more details on writing migrations.

</Note>

---

## Run the Migration

To run your migration, run the following command:

<Note>

This command also syncs module links. If you don't want that, use the `--skip-links` option.

</Note>

```bash
npx medusa db:migrate
```

This reflects the changes in the database as implemented in the migration's `up` method.

---

## Rollback the Migration

To rollback or revert the last migration you ran for a module, run the following command:

```bash
npx medusa db:rollback blog
```

This rolls back the last ran migration on the Blog Module.

### Caution: Rollback Migration before Deleting

If you need to delete a migration file, make sure to rollback the migration first. Otherwise, you might encounter issues when generating and running new migrations.

For example, if you delete the migration of the Blog Module, then try to create a new one, Medusa will create a brand new migration that re-creates the tables or indices. If those are still in the database, you might encounter errors.

So, always rollback the migration before deleting it.

---

## Data Migration Scripts

Some features might require data migrations to ensure new functionality works as expected after an upgrade. Typically, these migrations can be dealt with by database migrations within a module. However, this is not the case when the changes affect the data models in several modules or if the data is stored in a third-party system. In those scenarios, the data needs to be brought to the desired state.

To do so, you can use data migration scripts. They are very similar to regular scripts, in the sense that you have access to the dependency container, i.e. all modules. However, instead of running manually, data migration scripts are run automatically as part of running `medusa db:migrate`.

### How they work

The Medusa project, its plugins, and the core are scoured for files in the `src/migration-scripts` folder, which are then executed. The files should export a default function. These scripts are only run once, provided they succeed.

The flow is as follows:

- Find files
- Ensure the `script_migrations` table exists. If not, create it
- Identify pending migration scripts (scripts that have not been ran previously)
- Acquire a lock on the table
- Begin loop, for each script
  - Insert migration script in the database
  - Execute script
  - Mark script as finished
- Release lock

### Example

```ts title="src/migration-scripts/example.tsx"
import { MedusaModule } from "@medusajs/framework/modules-sdk"
import { ExecArgs } from "@medusajs/framework/types"
import { Modules } from "@medusajs/framework/utils"

export default async function migrationScript({
  container,
}: ExecArgs) {
  // Check if the required modules are present
  if (!MedusaModule.isInstalled(Modules.PRODUCT))
    return
  
  // Migrate data
  await migrateDataWorkflow(container).run(...)

}
```

---

## More Database Commands

To learn more about the Medusa CLI's database commands, refer to [this CLI reference](!resources!/medusa-cli/commands/db).
