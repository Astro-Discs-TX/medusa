import { CardList, SplitSections, SplitSection, CodeTabs, CodeTab, SplitList } from "docs-ui"

export const metadata = {
  title: `${pageNumber} Framework Overview`,
}

# {metadata.title}

In this chapter, you'll learn about the Medusa Framework. You'll learn about the concepts and tools that facilitate building customizations into your Medusa application.

## What is the Medusa Framework?

The Medusa Framework is built for customizations. It provides the tools that allow you to build custom features, integrate third-party services, extend existing features, automate tasks, and more.

While other ecommerce platforms limit your capabilities of building sophisticated customizations tailored for business use cases, the Medusa Framework is built to be flexible and extensible. It removes traditional limitations and unnecessary overheads, allowing you to focus on shipping new features.

### Framework Concepts and Tools

<SplitList
  items={[
    {
      title: "Medusa Container",
      link: "/learn/fundamentals/medusa-container",
    },
    {
      title: "Modules",
      link: "/learn/fundamentals/modules",
    },
    {
      title: "Module Links",
      link: "/learn/fundamentals/module-links",
    },
    {
      title: "Query",
      link: "/learn/fundamentals/module-links/query",
    },
    {
      title: "Data Models",
      link: "/learn/fundamentals/data-models",
    },
    {
      title: "Workflows",
      link: "/learn/fundamentals/workflows",
    },
    {
      title: "API Routes",
      link: "/learn/fundamentals/api-routes",
    },
    {
      title: "Events and Subscribers",
      link: "/learn/fundamentals/events-and-subscribers",
    },
    {
      title: "Scheduled Jobs",
      link: "/learn/fundamentals/scheduled-jobs",
    },
    {
      title: "Plugins",
      link: "/learn/fundamentals/plugins",
    }
  ]}
  listsNum={2}
/>

---

## Build Custom Features

The Medusa Framework allows you to build custom features that are tailored to your business needs.

To create a custom feature, you can create a [module](../modules/page.mdx) that contains your feature's data models and the logic to manage them. A module is integrated into your Medusa application without side effects.

<CodeTabs group="module-customizations">
  <CodeTab label="Data Model" value="data-model">

```ts
import { model } from "@medusajs/framework/utils"

export const Post = model.define("post", {
  id: model.id().primaryKey(),
  title: model.text(),
})
```

  </CodeTab>

  <CodeTab label="Service" value="service">

```ts
import { MedusaService } from "@medusajs/framework/utils"
import { Post } from "./post"

export class BlogModuleService extends MedusaService({
  Post,
}){
  // CRUD methods generated by MedusaService
}
```

  </CodeTab>

  <CodeTab label="Module Definition" value="module">

```ts
import { Module } from "@medusajs/framework/utils"
import { BlogModuleService } from "./service"

export const BLOG_MODULE = "blog"

export default Module(BLOG_MODULE, {
  service: BlogModuleService,
})
```

  </CodeTab>

</CodeTabs>

Then, you can build [workflows](../workflows/page.mdx) around your module that provide commerce features with rollback mechanism.

<CodeTabs group="workflow-customizations">
  <CodeTab label="Step" value="step">

```ts
import { createStep, StepResponse } from "@medusajs/framework/workflows-sdk"
import { BlogModuleService, BLOG_MODULE } from "../../modules/blog"

type Input = {
  title: string
}

const createPostStep = createStep(
  "create-post", 
  async (input: Input, { container }) => {
    const blogModuleService: BlogModuleService = container.resolve(
      BLOG_MODULE
    )

    const post = await blogModuleService.createPosts(input.title)
    
    return new StepResponse(post, post.id)
  },
  async (postId, { container }) => {
    if (!postId) {
      return
    }

    const blogModuleService: BlogModuleService = container.resolve(
      BLOG_MODULE
    )

    await blogModuleService.deletePosts(postId)
  }
)
```

  </CodeTab>
  <CodeTab label="Workflow" value="workflow">

```ts
import { createWorkflow, WorkflowResponse } from "@medusajs/framework/workflows-sdk"
import { createPostStep } from "./steps"

type Input = {
  title: string
}

export const createPostWorkflow = createWorkflow(
  "create-post",
  (input: Input) => {
    const post = createPostStep(input)

    return new WorkflowResponse(post)
  }
)
```

  </CodeTab>
</CodeTabs>

Finally, you can expose your custom feature with [API routes](../api-routes/page.mdx) that are built on top of your module and workflows.

```ts title="API Route Example"
import type {
  MedusaRequest,
  MedusaResponse,
} from "@medusajs/framework/http"
import { createPostWorkflow } from "../../../workflows/create-post"

type PostRequestBody = {
  title: string
}

export const POST = (
  req: MedusaRequest<PostRequestBody>,
  res: MedusaResponse
) => {
  const { result } = await createPostWorkflow(req.scope)
    .run({
      input: result.validatedBody
    })
}
```

### Examples

The following tutorials are step-by-step guides that show you how to build custom features using the Medusa Framework.

<CardList
  items={[
    {
      title: "Product Reviews",
      text: "Build product reviews feature in your Medusa application.",
      href: "!resources!/how-to-tutorials/tutorials/product-reviews",
    },
    {
      title: "Wishlist",
      text: "Build wishlist feature in your Medusa application.",
      href: "!resources!/plugins/guides/wishlist",
    }
  ]}
/>

### Start Learning

To learn more about the different concepts useful for building custom features, check out the following chapters:

<CardList
  items={[
    {
      title: "Modules",
      href: "/learn/fundamentals/modules",
    },
    {
      title: "Workflows",
      href: "/learn/fundamentals/workflows",
    },
    {
      title: "API Routes",
      href: "/learn/fundamentals/api-routes",
    }
  ]}
/>

---

## Extend Existing Models and Features

The Medusa Framework is flexible and extensible, allowing you to extend and build on top of existing models and features.

To extend an existing model, you can create a [module](../modules/page.mdx) that contains your additions to existing data models or features. Then, you can define a [module link](../module-links/page.mdx) that associates two data models from separate modules.

<CodeTabs group="module-extensions">
  <CodeTab label="Module Link" value="module-link">

```ts
import BrandModule from "../modules/brand"
import ProductModule from "@medusajs/medusa/product"
import { defineLink } from "@medusajs/framework/utils"

export default defineLink(
  {
    linkable: ProductModule.linkable.product,
    isList: true,
  },
  BrandModule.linkable.brand
)
```

  </CodeTab>

  <CodeTab label="Data Model" value="data-model">

```ts
import { model } from "@medusajs/framework/utils"

export const Brand = model.define("brand", {
  id: model.id().primaryKey(),
  name: model.text(),
})
```

  </CodeTab>

  <CodeTab label="Service" value="service">

```ts
import { MedusaService } from "@medusajs/framework/utils"
import { Brand } from "./models/brand"

class BrandModuleService extends MedusaService({
  Brand,
}) {

}

export default BrandModuleService
```

  </CodeTab>

  <CodeTab label="Module Definition" value="module">

```ts
import { Module } from "@medusajs/framework/utils"
import BrandModuleService from "./service"

export const BRAND_MODULE = "brand"

export default Module(BRAND_MODULE, {
  service: BrandModuleService,
})
```

  </CodeTab>
</CodeTabs>

Then, you can [hook into existing workflows](../workflows/workflow-hooks/page.mdx) to perform custom actions as part of existing features. For example, you can create a brand when a product is created.

```ts title="Workflow Hook Example"
import { createProductsWorkflow } from "@medusajs/medusa/core-flows"
import { StepResponse } from "@medusajs/framework/workflows-sdk"
import { Modules } from "@medusajs/framework/utils"
import { LinkDefinition } from "@medusajs/framework/types"
import { BRAND_MODULE } from "../../modules/brand"
import BrandModuleService from "../../modules/brand/service"

createProductsWorkflow.hooks.productsCreated(
  (async ({ products, additional_data }, { container }) => {
    if (!additional_data?.brand_id) {
      return new StepResponse([], [])
    }

    const brandModuleService: BrandModuleService = container.resolve(
      BRAND_MODULE
    )
    // if the brand doesn't exist, an error is thrown.
    await brandModuleService.retrieveBrand(additional_data.brand_id as string)

    // TODO link brand to product
  })
)
```

You can also build custom workflows using your custom module and Medusa's modules. You can also use [existing workflows and steps](!resources!/medusa-workflows-reference) within your custom workflows.

### Examples

The following tutorials are step-by-step guides that show you how to extend existing features using the Medusa Framework.

<CardList
  items={[
    {
      title: "Custom Item Pricing",
      text: "Add products wth custom items to the cart.",
      href: "!resources!/examples/guides/custom-item-price",
    },
    {
      title: "Extend Product Module",
      text: "Extend the Product Module with custom fields.",
      href: "!resources!/commerce-modules/product/extend#content",
    }
  ]}
/>

### Start Learning

To learn more about the different concepts useful for extending features, check out the following chapters:

<CardList
  items={[
    {
      title: "Modules",
      href: "/learn/fundamentals/modules",
    },
    {
      title: "Module Links",
      href: "/learn/fundamentals/module-links",
    },
    {
      title: "Workflow Hooks",
      href: "/learn/fundamentals/workflows/workflow-hooks",
    }
  ]}
/>

---

## Integrate Third-Party Services

The Medusa Framework provides the tools and infrastructure to build a middleware solution for your commerce ecosystem.

### Orchestrate Operations Across Systems

The Medusa Framework solves one of the biggest hurdles for ecommerce platforms: orchestrating operations across systems. Medusa has a built-in durable execution engine to help complete tasks that span multiple systems.

You can integrate a third-party service in a [module](../modules/page.mdx). This module provides an interface to perform operations with the third-party service.

<CodeTabs group="third-party-integration">
  <CodeTab label="Service" value="service">

```ts
type Options = {
  apiKey: string
}

export default class ErpModuleService {
  private options: Options
  private client

  constructor({}, options: Options) {
    this.options = options
    // TODO initialize client that connects to ERP
  }

  async getProducts() {
    // assuming client has a method to fetch products
    return this.client.getProducts()
  }

  // TODO add more methods
}
```

  </CodeTab>

  <CodeTab label="Module Definition" value="module">

```ts
import { Module } from "@medusajs/framework/utils"
import ErpModuleService from "./service"

export const ERP_MODULE = "erp"

export default Module(ERP_MODULE, {
  service: ErpModuleService,
})
```

  </CodeTab>
</CodeTabs>

Then, you can build [workflows](../workflows/page.mdx) that perform operations across systems using your custom modules. For example, you can create a workflow that syncs products from your ERP system to your Medusa application.

<CodeTabs group="erp-sync-workflow">
  <CodeTab label="Step" value="step">

```ts
import { createStep, StepResponse } from "@medusajs/framework/workflows-sdk"
import { ERP_MODULE } from "../../modules/erp"
import { ErpModuleService } from "../../modules/erp/service"

const getProductsFromErpStep = createStep(
  "get-products-from-erp",
  async (_, { container }) => {
    const erpModuleService: ErpModuleService = container.resolve(
      ERP_MODULE
    )

    const products = await erpModuleService.getProducts()

    return new StepResponse(products)
  }
)
```

  </CodeTab>

  <CodeTab label="Workflow" value="workflow">

```ts
import { 
  createWorkflow, 
  WorkflowResponse,
  transform,
} from "@medusajs/framework/workflows-sdk"
import { createProductsWorkflow } from "@medusajs/medusa/core-flows"

export const syncFromErpWorkflow = createWorkflow(
  "sync-from-erp",
  () => {
    const erpProducts = getProductsFromErpStep()

    const productsToCreate = transform({
      erpProducts,
    }, (data) => {
      // TODO prepare ERP products to be created in Medusa
      return data.erpProducts.map((erpProduct) => {
        return {
          title: erpProduct.title,
          external_id: erpProduct.id,
          variants: erpProduct.variants.map((variant) => ({
            title: variant.title,
            metadata: {
              external_id: variant.id,
            },
          })),
          // other data...
        }
      })
    })

    createProductsWorkflow.runAsStep({
      input: {
        products: productsToCreate,
      },
    })

    return new WorkflowResponse({
      erpProducts,
    })
  }
)
```

  </CodeTab>
</CodeTabs>

By using a workflow to manage operations across systems, you benefit from features like roll-back mechanism, background long-running execution, retry mechanism, and more. This is essential for building a middleware solution that orchestrates operations across systems, as you don't have to worry about data inconsistencies or failures.

You can then execute this workflow on a schedule using [scheduled jobs](../scheduled-jobs/page.mdx), execute it when an event occurs using [events and subscribers](../events-and-subscribers/page.mdx), or expose it as a feature in an [API route](../api-routes/page.mdx).

<CodeTabs group="erp-sync-api">
  <CodeTab label="Scheduled Job" value="scheduled-job">

```ts
import {
  MedusaContainer,
} from "@medusajs/framework/types"
import { syncFromErpWorkflow } from "../workflows/sync-from-erp"

export default async function syncProductsJob(container: MedusaContainer) {
  await syncFromErpWorkflow(container).run({})
}

export const config = {
  name: "daily-product-sync",
  schedule: "0 0 * * *", // Every day at midnight
}
```

  </CodeTab>

  <CodeTab label="Event Subscriber" value="event-subscriber">

```ts
import { SubscriberArgs, type SubscriberConfig } from "@medusajs/framework"
import { sendOrderConfirmationWorkflow } from "../workflows/send-order-confirmation"

export default async function productsCreatedHandler({
  event: { data },
  container,
}: SubscriberArgs<{ id: string }[]>) {
  await syncFromErpWorkflow(container).run({})
}

export const config: SubscriberConfig = {
  event: `product.created`,
}
```

  </CodeTab>

  <CodeTab label="API Route" value="api-route">

```ts
import type {
  MedusaRequest,
  MedusaResponse,
} from "@medusajs/framework/http"
import { syncFromErpWorkflow } from "../../../workflows/sync-from-erp"

export const POST = async (
  req: MedusaRequest,
  res: MedusaResponse
) => {
  const { result } = await syncFromErpWorkflow(req.scope).run({})

  return res.status(200).json(result)
}
```

  </CodeTab>
</CodeTabs>

#### Examples

The following tutorials are step-by-step guides that show you how to orchestrate operations across third-party services using the Medusa Framework.

<CardList
  items={[
    {
      title: "Migrate Data from Magento",
      text: "Migrate data from Magento to your Medusa application.",
      href: "!resources!/integrations/guides/magento",
    },
    {
      title: "Integrate Third-Party Services",
      text: "Integrate CMS, Fulfillment, Payment, and other third-party services.",
      href: "!resources!/integrations",
    }
  ]}
/>

#### Start Learning

To learn more about the different concepts useful for integrating third-party services, check out the following chapters:

<CardList
  items={[
    {
      title: "Modules",
      href: "/learn/fundamentals/modules",
    },
    {
      title: "Workflows",
      href: "/learn/fundamentals/workflows",
    },
    {
      title: "API Routes",
      href: "/learn/fundamentals/api-routes",
    },
    {
      title: "Events and Subscribers",
      href: "/learn/fundamentals/events-and-subscribers",
    },
    {
      title: "Scheduled Jobs",
      href: "/learn/fundamentals/scheduled-jobs",
    }
  ]}
/>

### Query Data Across Systems

Another essential feature for integrating third-party services is the ability to query data across those systems efficiently.

The Medusa Framework allows you to build links not only between data models, but also virtual data models using [read-only module links](../module-links/read-only/page.mdx). You can build a module that provides the logic to query data from a third-party service, then create a read-only link between an existing data model and a virtual one from the third-party service.

<CodeTabs group="erp-query">
  <CodeTab label="Read-Only Link" value="read-only-link">

```ts
import BrandModule from "../modules/brand"
import ProductModule from "@medusajs/medusa/product"
import { defineLink } from "@medusajs/framework/utils"

export default defineLink(
  {
    linkable: ProductModule.linkable.product,
    field: "id",
  },
  {
    ...BrandModule.linkable.brand.id,
    primaryKey: "product_id",
  },
  {
    readOnly: true,
  }
)
```

  </CodeTab>

  <CodeTab label="Module Service" value="module-service">

```ts
type BrandModuleOptions = {
  apiKey: string
}

export default class BrandModuleService {
  private client

  constructor({}, options: BrandModuleOptions) {
    this.client = new Client(options)
  }

  async list(
    filter: {
      id: string | string[]
    }
  ) {
    return this.client.getBrands(filter)
    /**
     * Example of returned data:
     * 
     * [
     *   {
     *     "id": "brand_123",
     *     "name": "Brand 123",
     *     "product_id": "prod_321"
     *   },
     *   {
     *     "id": "post_456",
     *     "name": "Brand 456",
     *     "product_id": "prod_654"
     *   }
     * ]
    */
  }
}
```

  </CodeTab>

  <CodeTab label="Module Definition" value="module">

```ts
import { Module } from "@medusajs/framework/utils"
import BrandModuleService from "./service"

export const BRAND_MODULE = "brand"

export default Module(BRAND_MODULE, {
  service: BrandModuleService,
})
```

  </CodeTab>
</CodeTabs>

Then, you can use [Query](../module-links/query/page.mdx) to retrieve a product and its brand from the third-party service in a single query.

```ts title="Query Example"
const { result } = await query.graph({
  entity: "product",
  fields: ["id", "brand.*"],
  filters: {
    id: "prod_123",
  },
})

// result = [{
//   id: "prod_123",
//   brand: {
//     id: "brand_123",
//     name: "Brand 123",
//     product_id: "prod_123"
//   }
//   ...
// }]
```

This simplifies the process of querying data across systems, as you can retrieve data from multiple sources in a single query.

#### Examples

The following tutorials are step-by-step guides that show you how to query data across systems using the Medusa Framework.

<CardList
  items={[
    {
      title: "Integrate Sanity CMS",
      text: "Query data from third-party services using read-only links.",
      href: "!resources!/integrations/guides/sanity",
    }
  ]}
/>

#### Start Learning

To learn more about the different concepts useful for querying data across systems, check out the following chapters:

<CardList
  items={[
    {
      title: "Modules",
      href: "/learn/fundamentals/modules",
    },
    {
      title: "Read-Only Module Links",
      href: "/learn/fundamentals/module-links/read-only",
    },
    {
      title: "Query",
      href: "/learn/fundamentals/module-links/query",
    }
  ]}
/>

---

## Automate Tasks

The Medusa Framework provides the tools to automate tasks in your Medusa application. Automation is useful when you want to perform a task periodically, such as syncing data, or when an event occurs, such as sending a confirmation email when an order is placed.

To build the task, you first create a [workflow](../workflows/page.mdx) that contains the task's logic, such as syncing data or sending an email.

<CodeTabs group="automate-tasks">
  <CodeTab label="Step" value="step">

```ts
import { Modules } from "@medusajs/framework/utils"
import { createStep, StepResponse } from "@medusajs/framework/workflows-sdk"
import { CreateNotificationDTO } from "@medusajs/framework/types"

export const sendNotificationStep = createStep(
  "send-notification",
  async (data: CreateNotificationDTO[], { container }) => {
    const notificationModuleService = container.resolve(
      Modules.NOTIFICATION
    )
    const notification = await notificationModuleService.createNotifications(
      data
    )
    return new StepResponse(notification)
  }
)
```

  </CodeTab>
  <CodeTab label="Workflow" value="workflow">

```ts
import { 
  createWorkflow, 
  WorkflowResponse,
} from "@medusajs/framework/workflows-sdk"
import { useQueryGraphStep } from "@medusajs/medusa/core-flows"
import { sendNotificationStep } from "./steps/send-notification"

type WorkflowInput = {
  id: string
}

export const sendOrderConfirmationWorkflow = createWorkflow(
  "send-order-confirmation",
  ({ id }: WorkflowInput) => {
    // @ts-ignore
    const { data: orders } = useQueryGraphStep({
      entity: "order",
      fields: [
        "id",
        "email",
        "currency_code",
        "total",
        "items.*",
      ],
      filters: {
        id,
      },
    })
    
    const notification = sendNotificationStep([{
      to: orders[0].email,
      channel: "email",
      template: "order-placed",
      data: {
        order: orders[0],
      },
    }])

    return new WorkflowResponse(notification)
  }
)
```
  </CodeTab>
</CodeTabs>

Then, you can execute this workflow when an event occurs using a [subscriber](../events-and-subscribers/page.mdx), or at a specific interval using a [scheduled job](../scheduled-jobs/page.mdx).

<CodeTabs group="automate-tasks-examples">
  <CodeTab label="Event Subscriber" value="event-subscriber">

```ts
import type {
  SubscriberArgs,
  SubscriberConfig,
} from "@medusajs/framework"
import { sendOrderConfirmationWorkflow } from "../workflows/send-order-confirmation"

export default async function orderPlacedHandler({
  event: { data },
  container,
}: SubscriberArgs<{ id: string }>) {
  await sendOrderConfirmationWorkflow(container)
    .run({
      input: {
        id: data.id,
      },
    })
}

export const config: SubscriberConfig = {
  event: "order.placed",
}
```

  </CodeTab>

  <CodeTab label="Scheduled Job" value="scheduled-job">

```ts
import type {
  MedusaContainer,
} from "@medusajs/framework/types"
import { sendOrderConfirmationWorkflow } from "../workflows/send-order-confirmation"

export default async function orderConfirmationJob(
  container: MedusaContainer
) {
  await sendOrderConfirmationWorkflow(container).run({
    input: {
      id: "order_123",
    }
  })
}
export const config = {
  name: "order-confirmation-job",
  schedule: "0 0 * * *", // Every day at midnight
}
```

  </CodeTab>
</CodeTabs>

### Examples

The following tutorials are step-by-step guides that show you how to automate tasks using the Medusa Framework.

<CardList
  items={[
    {
      title: "Restock Notifications",
      text: "Send restock notifications to customers when a product is back in stock.",
      href: "!resources!/recipes/commerce-automation/restock-notification",
    },
    {
      title: "Sync Data from and to ERP",
      text: "Sync data between your Medusa application and an ERP system.",
      href: "!resources!/recipes/erp#sync-products-from-erp",
    }
  ]}
/>

### Start Learning

To learn more about the different concepts useful for automating tasks, check out the following chapters:

<CardList
  items={[
    {
      title: "Workflows",
      href: "/learn/fundamentals/workflows",
    },
    {
      title: "Events and Subscribers",
      href: "/learn/fundamentals/events-and-subscribers",
    },
    {
      title: "Scheduled Jobs",
      href: "/learn/fundamentals/scheduled-jobs",
    }
  ]}
/>

---

## Re-Use Customizations Across Applications

If you have custom features that you want to re-use across multiple Medusa applications, or you want to publish your customizations for the community to use, you can build a [plugin](../plugins/page.mdx).

A plugin can encapsulate different customizations in a single package. That includes [modules](../modules/page.mdx), [workflows](../workflows/page.mdx), [API routes](../api-routes/page.mdx), and more.

![Diagram showcasing a wishlist plugin installed in a Medusa application](https://res.cloudinary.com/dza7lstvk/image/upload/v1737540762/Medusa%20Book/plugin-diagram_oepiis.jpg)

You can then publish that plugin to NPM and install it in any Medusa application. This allows you to re-use your customizations efficiently across multiple projects, or share them with the community.

### Examples

The following tutorials are step-by-step guides that show you how to build plugins using the Medusa Framework.

<CardList
  items={[
    {
      title: "Wishlist Plugin",
      text: "Build a wishlist plugin for your Medusa application.",
      href: "!resources!/plugins/guides/wishlist",
    },
    {
      title: "Migrate Data from Magento Plugin",
      text: "Build a plugin that migrates data from Magento to your Medusa application.",
      href: "!resources!/integrations/guides/magento",
    }
  ]}
/>

### Start Learning

To learn more about the different concepts useful for building plugins, check out the following chapters:

<CardList
  items={[
    {
      title: "Plugins",
      href: "/learn/fundamentals/plugins",
    },
  ]}
  itemsPerRow={1}
/>
