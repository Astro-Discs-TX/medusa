export const metadata = {
  title: `${pageNumber} How to Pass Additional Data to Extend API Routes`,
}

In this chapter, you'll learn how to extend existing API routes to pass additional data and perform additional functionalities.

## When to Pass Additional Data to API Routes?

After you define links between data models, you want to expose functionalities in API routes that manage these links.

For example, after linking brands to products, you want an admin user to set the brand of a product.

Some API routes, such as the [Create Product API route](https://docs.medusajs.com/v2/api/admin#products_postproducts), accept an `additional_data` request body parameter. This parameter allows you to pass custom data to the API route, then use it to perform additional actions.

This chapter explains how to pass a brand ID to the Create Product API route, then link the brand to the created product.

---

## 1. Additinal Data Validation in API Routes

Before passing the brand ID in the `additional_data` parameter, you must define how this custom parameter is validated.

You specify additional data validation in the special file `src/api/middlewares.ts`. This file calls the `defineMiddlewares` function imported from `@medusajs/medusa` to define middlewares or additional data validation, and exports its value.

For example, create the file `src/api/middlewares.ts` with the following content:

```ts title="src/api/middlewares.ts"
import { defineMiddlewares } from "@medusajs/medusa"
import { z } from "zod"

export default defineMiddlewares({
  routes: [
    {
      matcher: "/admin/products",
      method: "POST",
      additionalDataValidator: {
        brand_id: z.string().optional()
      }
    }
  ]
})
```

The `defineMiddlewares` function accept an object having the `routes` property. `routes`' value is an array of middleware route objects, each having the following properties:

- `matcher`: a string or regular expression indicating the API route path to apply the middleware on. The regular expression must be compatible with [path-to-regexp](https://github.com/pillarjs/path-to-regexp).
- `method`: An optional array of strings, each indicating an HTTP method to apply the middleware or additional data validation to. If not supplied, it's applied to all HTTP methods.
- `additionalDataValidator`: An object of key-value pairs defining how to validate the properties passed under the `additional_data` parameter. Each key indicate a property's name, and its value is its validation rules using [Zod](https://zod.dev/).

In this example, you add a validation rule to the `additional_data` request body parameter that it can include a `brand_id` of type string.

---

## 2. Perform Additional Action using Workflow Hooks

A workflow hook is a point in a workflow where you can inject custom functionality as a step function, called a hook handler.

Medusa exposes hooks in many of its workflows that are used in its API routes. You can consume those hooks to add your custom logic.

<Note title="Tip">

The [Store](!api!/store) and [Admin](!api!/admin) API references indicate what workflows are used in each API routes. By clicking on them, you access the [workflow's reference](!resources!/medusa-workflows-reference) where you can see the hooks available in the workflow.

</Note>

The [createProductsWorkflow](!resources!/references/medusa-workflows/createProductsWorkflow) used in the Create Product API route has a `productsCreated` hook that runs its hook handler after the product is created.

So, to link a brand to the created products, create the file `src/workflows/hooks/created-product.ts` with the following content:

```ts title="src/workflows/hooks/created-product.ts"
import { createProductsWorkflow } from "@medusajs/core-flows"
import { Modules } from "@medusajs/utils"
import { BRAND_MODULE } from "../../modules/brand"
import BrandModuleService from "../../modules/brand/service"

createProductsWorkflow.hooks.productsCreated(
	(async ({ products, additional_data }, { container }) => {
    if (!additional_data.brand_id) {
      return
    }

    // check that brand exists
    const brandModuleService: BrandModuleService = container.resolve(
      BRAND_MODULE
    )
    // if the brand doesn't exist, an error is thrown.
    await brandModuleService.retrieveBrand(additional_data.brand_id as string)

		const remoteLink = container.resolve("remoteLink")

    // link products to brands
    for (const product of products) {
      remoteLink.create({
        [Modules.PRODUCT]: {
          product_id: product.id
        },
        [BRAND_MODULE]: {
          brand_id: additional_data.brand_id
        }
      })
    }

    console.log("Linked brand to products")
	})
)
```

You consume the `productsCreated` hook of the `createProductsWorkflow`. In the hook handler, you:

1. Check that the `brand_id` is passed in `additional_data`. If not, you return.
2. Check that the brand exists using the `retrieveBrand` method of the Brand Module's main service. The method throws an error if a brand with the specified ID doesn't exist.
3. Loop over the created products and create a remote link between each of them and the brand.

---

## Test it Out

To test it out, first, retrieve the authentication token of your admin user by sending a `POST` request to `/auth/user/emailpass`:

```bash
curl -X POST 'http://localhost:9000/auth/user/emailpass' \
-H 'Content-Type: application/json' \
--data-raw '{
    "email": "admin@medusa-test.com",
    "password": "supersecret"
}'
```

Make sure to replace the email and password with your user's credentials.

Then, send a `POST` request to `/admin/products` to create a product, and pass in the `additional_data` parameter a brand's ID:

```bash
curl -X POST 'http://localhost:9000/admin/products' \
-H 'Content-Type: application/json' \
-H 'Authorization: Bearer {token}' \
--data '{
    "title": "Product 1",
    "additional_data": {
        "brand_id": "01J7AX9ES4X113HKY6C681KDZ2J"
    }
}'
```

<Note title="Tip">

Make sure to replace the `{token}` in the Authorization header with the token received from the previous request.

</Note>

In the request body, you pass in the `additional_data` parameter a `brand_id`.

The request creates a product and returns it. In the Medusa application's logs, you'll find the message `Linked brand to products`, indicating that the workflow hook handler ran and linked the brand to the products.
