export const metadata = {
  title: `${pageNumber} Multiple Services in a Module`,
}

# {metadata.title}

In this chapter, you'll learn how to use multiple services in a module.

## Module's Main and Internal Services

A module has one main service only, which is the service exported in the module's definition.

However, you may use other services in your module to better organize your code or split functionalities. These are called internal services that can be resolved within your module, but not in external resources.

---

## How to Add an Internal Service

### 1. Create Service

To add an internal service, create it in the `services` directory of your module.

For example, create the file `src/modules/hello/services/client.ts` with the following content:

```ts title="src/modules/hello/services/client.ts"
export class ClientService {
  async getMessage(): Promise<string> {
    return "Hello, World!"
  }
}
```

### 2. Export Service in Index

Next, create an `index.ts` file under the `services` directory of the module that exports your internal services.

For example, create the file `src/modules/hello/services/index.ts` with the following content:

```ts title="src/modules/hello/services/index.ts"
export * from "./client"
```

This exports the `ClientService`.

### 3. Resolve Internal Service

Internal services exported in the `services/index.ts` file of your module are now registered in the container and can be resolved in other services in the module as well as loaders.

For example, in your main service:

```ts title="src/modules/hello/service.ts" highlights={[["5"], ["13"]]}
// other imports...
import { ClientService } from "./services"

type InjectedDependencies = {
  clientService: ClientService
}

class HelloModuleService extends MedusaService({
  MyCustom,
}){
  protected clientService_: ClientService

  constructor({ clientService }: InjectedDependencies) {
    super(...arguments)
    this.clientService_ = clientService
  }
}
```

You can now use your internal service in your main service.

---

## Resolve Resources in Internal Service

Resolve dependencies from your module's container in the constructor of your internal service.

For example:

```ts
import { Logger } from "@medusajs/types"

type InjectedDependencies = {
  logger: Logger
}

export class ClientService {
  protected logger_: Logger

  constructor({ logger }: InjectedDependencies) {
    this.logger_ = logger
  }
}
```

---

## Access Module Options

Your internal service can't access the module's options.

If you need the options in your internal service:

1. Add an `options` property in the service and a method to set it:

```ts
export class ClientService {
  protected options: Record<string, any>

  async setOptions(value: Record<string, any>) {
    this.options = value
  }
}
```

2. In the main service's constructor, use the `setOptions` method on the internal service when adding it as a property of the main service:

```ts
// other imports...
import { ClientService } from "./services"

type InjectedDependencies = {
  clientService: ClientService
}

class HelloModuleService extends MedusaService({
  MyCustom,
}){
  protected clientService_: ClientService

  constructor(
    { clientService }: InjectedDependencies,
    options: Record<string, any>
  ) {
    super(...arguments)
    this.clientService_ = clientService

    this.clientService_.setOptions(options)
  }
}
```

The options will only be set on the instance of the internal service in the module. So, when you use the internal service in other method's of the main module, the options will be set on it.
