---
sidebar_label: "Phone Authentication"
tags:
    - name: auth
      label: "Implement Phone Authentication"
    - name: customer
      label: "Implement Phone Authentication"
    - server
    - tutorial
---

import { Github, PlaySolid } from "@medusajs/icons"
import { Prerequisites, WorkflowDiagram, CardList } from "docs-ui"

export const metadata = {
  title: `Implement Phone Authentication and Integrate Twilio SMS`,
}

# {metadata.title}

In this tutorial, you will learn how to implement phone authentication in your Medusa application to allow customers to log in with their phone numbers.

When you install a Medusa application, you get a fully-fledged commerce platform with a Framework for customization. The Medusa application's commerce features are built around [Commerce Modules](../../../commerce-modules/page.mdx), which are available out-of-the-box. These features include authentication with custom providers and for custom user types.

In this tutorial, you'll learn how to implement a custom authentication provider that allows users to log in with their phone number. You'll also integrate [Twilio SMS](https://www.twilio.com/en-us/messaging/channels/sms) to send SMS messages to those users with one-time passwords (OTPs) for authentication.

<Note>

You can integrate a different SMS provider or use a different method to send OTPs. The tutorial will focus on the Medusa application and the Twilio SMS provider, but you can adapt it to your needs.

</Note>

You can follow this tutorial whether you're new to Medusa or an advanced Medusa developer.

## Summary

By following this tutorial, you will learn how to:

- Install and set up Medusa.
- Implement a custom phone authentication provider.
- Integrate Twilio SMS to send OTPs.
- Customize the Next.js Starter Storefront to allow customers to log in with their phone numbers.

{/* TODO add diagram */}

<Note>

While this tutorial focuses on supporting phone authentication for customers, you can use the authentication provider for any actor type, such as admin user or vendor. [At the end of this tutorial](#next-steps), you'll learn how to authenticate other actor types.

</Note>

<CardList items={[
  {
    href: "https://github.com/medusajs/examples/tree/main/phone-auth",
    title: "Phone Authentication Repository",
    text: "Find the full code for this guide in this repository.",
    icon: Github,
  },
  {
    // TODO update
    href: "https://res.cloudinary.com/dza7lstvk/raw/upload/v1744212595/OpenApi/Loyalty-Points_jwi5e9.yaml",
    title: "OpenApi Specs for Postman",
    text: "Import this OpenApi Specs file into tools like Postman.",
    icon: PlaySolid,
  },
]} />

---

## Step 1: Install a Medusa Application

<Prerequisites items={[
  {
    text: "Node.js v20+",
    link: "https://nodejs.org/en/download"
  },
  {
    text: "Git CLI tool",
    link: "https://git-scm.com/downloads"
  },
  {
    text: "PostgreSQL",
    link: "https://www.postgresql.org/download/"
  }
]} />

Start by installing the Medusa application on your machine with the following command:

```bash
npx create-medusa-app@latest
```

You'll first be asked for the project's name. Then, when asked whether you want to install the [Next.js Starter Storefront](../../../nextjs-starter/page.mdx), choose Yes.

Afterward, the installation process will start, which will install the Medusa application in a directory with your project's name, and the Next.js Starter Storefront in a separate directory with the `{project-name}-storefront` name.

<Note title="Why is the storefront installed separately">

The Medusa application is composed of a headless Node.js server and an admin dashboard. The storefront is installed or custom-built separately and connects to the Medusa application through its REST endpoints, called [API routes](!docs!/learn/fundamentals/api-routes). Learn more in [Medusa's Architecture documentation](!docs!/learn/introduction/architecture).

</Note>

Once the installation finishes successfully, the Medusa Admin dashboard will open with a form to create a new user. Enter the user's credentials and submit the form. Afterward, you can log in with the new user and explore the dashboard.

<Note title="Ran into Errors">

Check out the [troubleshooting guides](../../../troubleshooting/create-medusa-app-errors/page.mdx) for help.

</Note>

---

## Step 2: Implement Phone Authentication Module Provider

In Medusa, you integrate custom authentication providers by creating an [Authentication Module Provider](../../../commerce-modules/auth/auth-providers/page.mdx). Then, you can use that provider to authenticate users using custom logic.

In this step, you'll create a Phone Authentication Module Provider that allows users to log in with their phone numbers and an OTP. Later, you'll integrate Twilio SMS to send the OTPs to the users, and customize the storefront to allow customers to log in with their phone numbers.

<Note title="Good to Know">

An Authentication Module Provider doesn't need to handle storing and managing specific user details, such as creating customers or admin users. Instead, it only focuses on the logic of authenticating a type of user using custom logic or integration. You can learn more in the [Auth Module](../../../commerce-modules/auth/page.mdx) documentation.

</Note>

### a. Create Module Directory

Modules are created under the `src/modules` directory. So, start by creating the directory `src/modules/phone-auth`.

### b. Create Auth Module Provider Service

A module has a service that contains its logic. For Authentication Module Providers, the service implements the logic to authenticate users.

To create the service of the Phone Authentication Module Provider, create the file `src/modules/phone-auth/service.ts` with the following content:

```ts title="src/modules/phone-auth/service.ts"
import { 
  AbstractAuthModuleProvider, 
  AbstractEventBusModuleService, 
} from "@medusajs/framework/utils"
import { 
  Logger, 
} from "@medusajs/types"

type InjectedDependencies = {
  logger: Logger
  event_bus: AbstractEventBusModuleService
}

type Options = {
  jwtSecret: string
}

class PhoneAuthService extends AbstractAuthModuleProvider {
  static DISPLAY_NAME = "Phone Auth"
  static identifier = "phone-auth"
  private options: Options
  private logger: Logger
  private event_bus: AbstractEventBusModuleService

  constructor(container: InjectedDependencies, options: Options) {
    // @ts-ignore
    super(...arguments)

    this.options = options
    this.logger = container.logger
    this.event_bus = container.event_bus
  }
}

export default PhoneAuthService
```

An Authentication Module Provider's service must extend the `AbstractAuthModuleProvider` class. You'll get a type error about implementing the abstract methods of that class, which you'll add in the next steps.

An Authentication Module Provider must also have the following static properties:

- `identifier`: A unique identifier for the module.
- `DISPLAY_NAME`: A human-readable name for the module. This name is used for display purposes.

A module provider's constructor receives two parameters:

- `container`: The [module's container](!docs!/learn/fundamentals/modules/container) that contains Framework resources available to the module. You access the following resources:
    - `logger`: A [Logger](!docs!/learn/debugging-and-testing/logging) class to log debug messages.
    - `event_bus`: The [Event Module](../../../infrastructure-modules/event/page.mdx)'s service to emit events.
- `options`: Options that are passed to the module provider when it's registered in Medusa's configurations. You define the following option:
    - `jwtSecret`: A secret used to sign and verify the OTPs.

<Note>

You'll learn how to set these options when you [add the module provider to Medusa's configurations](#h-add-module-provider-to-medusas-configurations).

</Note>

In the constructor, you set the class's properties to the injected dependencies and options.

In the next sections, you'll implement the methods of the `AbstractAuthModuleProvider` class.

<Note>

Refer to the [Create Auth Module Provider](/references/auth/provider) guide for detailed information about the methods.

</Note>

### c. Implement validateOptions Method

The `validateOptions` method is used to validate the options passed to the module provider. If the method throws an error, the Medusa application won't start.

So, add the `validateOptions` method to the `PhoneAuthService` class:

```ts title="src/modules/phone-auth/service.ts"
// other imports...
import { 
  MedusaError
} from "@medusajs/framework/utils"

class PhoneAuthService extends AbstractAuthModuleProvider {
  // ...
  static validateOptions(options: Record<any, any>): void | never {
    if (!options.jwtSecret) {
      throw new MedusaError(
        MedusaError.Types.INVALID_DATA,
        "JWT secret is required"
      )
    }
  }
}
```

The `validateOptions` method receives the options passed to the module provider as a parameter.

In the method, you throw an error if the `jwtSecret` option is not set.

### d. Implement register Method

When a customer (or other actor types) register in your application, they must also have an [auth identity](../../../commerce-modules/auth/auth-identity-and-actor-types/page.mdx) that allows them to login.

The `register` method of an auth provider uses custom logic to create the auth identity for the actor type. In the method, you can perform custom validation and specify the custom authentication details to store for the user's auth identity.

{/* TODO add diagram */}

Medusa uses the `register` method when retrieving a registration token for a customer when they register. You can learn more in the [Authentication Flows](../../../commerce-modules/auth/auth-flows/page.mdx) documentation.

So, add the `register` method to the `PhoneAuthService` class:

```ts title="src/modules/phone-auth/service.ts"
// other imports...
import { 
  AuthenticationInput, 
  AuthIdentityProviderService, 
  AuthenticationResponse, 
} from "@medusajs/types"

class PhoneAuthService extends AbstractAuthModuleProvider {
  // ...
  async register(
    data: AuthenticationInput,
    authIdentityProviderService: AuthIdentityProviderService
  ): Promise<AuthenticationResponse> {
    const { phone } = data.body || {}

    if (!phone) {
      return {
        success: false,
        error: "Phone number is required"
      }
    }

    try {
      await authIdentityProviderService.retrieve({
        entity_id: phone,
      })

      return {
        success: false,
        error: "User with phone number already exists"
      }
    } catch (error) {
      const user = await authIdentityProviderService.create({
        entity_id: phone,
      })

      return {
        success: true,
        authIdentity: user
      }
    }
  }
}
```

#### Parameters

The `register` method receives an object parameter with the following properties:

- `data`: An object containing properties like `body`, which is the request body. The `body` property typically holds data relevant for registration such as the user's phone number.
- `authIdentityProviderService`: A service injected by the [Auth Module](../../../commerce-modules/auth/page.mdx) that allows you to manage auth identities.

<Note>

The method receives other parameters, which you can find in the [Create Auth Module Provider](/references/auth/provider#register) guide.

</Note>

#### Method Logic

In the method, you extract the `phone` property from the request body, and return an error if it's not provided.

Then, if another user is using the same phone number, you throw an error.

Otherwise, you create a new auth identity for the user. You set the phone number as the `entity_id` of the auth identity, which is a unique identifier for the user.

#### Return Value

Finally, you return an object with the following properties:

- `success`: A boolean indicating whether the registration was successful.
- `authIdentity`: The created auth identity of the user. This property is only set if the registration was successful.
- `error`: An error message if the registration failed.

### e. Implement authenticate Method

When a customer (or other actor types) logs in, the `authenticate` method of an auth provider is called. This method uses custom logic to authenticate the user.

Based on the authentication provider, the authentication flow can vary:

- Direct authentication, where the user is authenticated using this method only.
- Authentication with callback verification, where the user is authenticated using this method and then a callback is used to verify additional information.

For the Phone Authentication Module Provider, you'll implement the second flow. The user will first be authenticated using the `authenticate` method to make sure the user exists. Later, they'll use the OTP they receive to verify their identity.

{/* TODO add diagram */}

So, add the `authenticate` method to the `PhoneAuthService` class:

```ts title="src/modules/phone-auth/service.ts"
// other imports...
import { 
  AuthIdentityDTO
} from "@medusajs/types"
import jwt from "jsonwebtoken"

class PhoneAuthService extends AbstractAuthModuleProvider {
  // ...
  async authenticate(
    data: AuthenticationInput,
    authIdentityProviderService: AuthIdentityProviderService
  ): Promise<AuthenticationResponse> {
    const { phone } = data.body || {}

    if (!phone) {
      return {
        success: false,
        error: "Phone number is required"
      }
    }

    try {
      await authIdentityProviderService.retrieve({
        entity_id: phone,
      })
    } catch (error) {
      return {
        success: false,
        error: "User with phone number does not exist"
      }
    }

    const { hashedOTP, otp } = await this.generateOTP()

    await authIdentityProviderService.update(phone, {
      provider_metadata: {
        otp: hashedOTP,
      }
    })

    await this.event_bus.emit({
      name: "phone-auth.otp.generated",
      data: {
        otp,
        phone,
      }
    }, {})

    return {
      success: true,
      location: "otp"
    }
  }

  async generateOTP(): Promise<{ hashedOTP: string, otp: string }> {
    // Generate a 6-digit OTP
    const otp = Math.floor(100000 + Math.random() * 900000).toString()

    // for debug
    this.logger.info(`Generated OTP: ${otp}`)
    
    const hashedOTP = jwt.sign({ otp }, this.options.jwtSecret, {
      expiresIn: "60s"
    })
    
    return { hashedOTP, otp }
  }
}
```

You add two methods: the `authenticate` method, and a helper `generateOTP` method.

#### authenticate Parameters

The `authenticate` method receives an object parameter with the following properties:

- `data`: An object containing properties like `body`, which is the request body. The `body` property typically holds data relevant for authentication such as the user's phone number.
- `authIdentityProviderService`: A service injected by the [Auth Module](../../../commerce-modules/auth/page.mdx) that allows you to manage auth identities.

<Note>

The method receives other parameters, which you can find in the [Create Auth Module Provider](/references/auth/provider#authenticate) guide.

</Note>

#### authenticate Logic

In the method, you extract the `phone` property from the request body, and return an error if it's not provided.

Then, you retrieve the user's auth identity using the `authIdentityProviderService`. If the user doesn't exist, you return an error.

Next, you generate a 6-digit OTP using the `generateOTP` method. Notice that you currently log the OTP for debugging purposes. You can remove this line later once you integrate Twilio SMS.

The OTP is hashed and stored in the `provider_metadata` property of the user's auth identity. The `provider_metadata` property is a JSON object that stores additional information about the auth identity.

Then, you emit an event with the generated OTP and the user's phone number. This allows you later to handle the event and send the OTP to the user using services like Twilio SMS.

#### authenticate Return Value

Finally, you return an object with the following properties:

- `success`: A boolean indicating whether the authentication was successful.
- `location`: The location indicates that the user should be perform additional verification. In this case, you set the location to `otp`, which indicates that the user should verify their OTP.
- `error`: An error message if the authentication failed.

### f. Implement validateCallback Method

When an authentication provider requires a callback to verify the user, the Medusa application calls the `validateCallback` method.

You can use this method to verify the OTP that the user entered. If valid, you return the logged in user, and the Medusa application will return a JWT token that the user can use to authenticate in the application.

So, add the `validateCallback` method to the `PhoneAuthService` class:

```ts title="src/modules/phone-auth/service.ts"
class PhoneAuthService extends AbstractAuthModuleProvider {
  // ...
  async validateCallback(
    data: AuthenticationInput,
    authIdentityProviderService: AuthIdentityProviderService
  ): Promise<AuthenticationResponse> {
    const { phone, otp } = data.query || {}

    if (!phone || !otp) {
      return {
        success: false,
        error: "Phone number and OTP are required"
      }
    }

    const user = await authIdentityProviderService.retrieve({
      entity_id: phone,
    })

    if (!user) {
      return {
        success: false,
        error: "User with phone number does not exist"
      }
    }
    
    // verify that OTP is correct
    const userProvider = user.provider_identities?.find((provider) => provider.provider === this.identifier)
    if (!userProvider || !userProvider.provider_metadata?.otp) {
      return {
        success: false,
        error: "User with phone number does not have a phone auth provider"
      }
    }
    
    try {
      const decodedOTP = jwt.verify(
        userProvider.provider_metadata.otp as string, 
        this.options.jwtSecret
      ) as { otp: string }
  
      if (decodedOTP.otp !== otp) {
        throw new Error("Invalid OTP")
      }
    } catch (error) {
      return {
        success: false,
        error: error.message || "Invalid OTP"
      }
    }
    
    const updatedUser = await authIdentityProviderService.update(phone, {
      provider_metadata: {
        otp: null,
      }
    })

    return {
      success: true,
      authIdentity: updatedUser
    }
  }
}
```

#### Parameters

The `validateCallback` method receives an object parameter with the following properties:

- `data`: An object containing properties like `query`, which is the request query. The `query` property typically holds data relevant for authentication such as the user's phone number and OTP.
- `authIdentityProviderService`: A service injected by the [Auth Module](../../../commerce-modules/auth/page.mdx) that allows you to manage auth identities.

<Note>

The method receives other parameters, which you can find in the [Create Auth Module Provider](/references/auth/provider#validatecallback) guide.

</Note>

#### Method Logic

In the method, you extract the `phone` and `otp` properties from the request query, and return an error if they're not provided.

Then, you retrieve the user's auth identity using the `authIdentityProviderService`. If the user doesn't exist, you return an error.

Next, you verify that the OTP provided by the user is correct. You retrieve the hashed OTP from the `provider_metadata` property of the user's auth identity. If the OTP is not valid, you return an error.

<Note>

Since you set the hash expiration to 60 seconds, the OTP will be valid for 60 seconds. After that, the user will need to request a new OTP.

</Note>

After that, you update the user's auth identity to remove the OTP from the `provider_metadata` property.

#### Return Value

Finally, you return an object with the following properties:

- `success`: A boolean indicating whether the authentication was successful.
- `authIdentity`: The user's auth identity. This property is only set if the authentication was successful.
- `error`: An error message if the authentication failed.

### g. Export Module Definition

You've now finished implementing the necessary methods for the Phone Authentication Module Provider.

The final piece to a module is its definition, which you export in an `index.ts` file at the module's root directory. This definition tells Medusa the name of the module, its service, and optionally its loaders.

To create the module's definition, create the file `src/modules/phone-auth/index.ts` with the following content:

```ts title="src/modules/phone-auth/index.ts"
import PhoneAuthService from "./service"
import { 
  ModuleProvider, 
  Modules
} from "@medusajs/framework/utils"

export default ModuleProvider(Modules.AUTH, {
  services: [PhoneAuthService],
})
```

You use `ModuleProvider` from the Modules SDK to create the module provider's definition. It accepts two parameters:

1. The name of the module that this provider belongs to, which is `Modules.AUTH` in this case.
2. An object with a required property `services` indicating the module provider's services. Each of these services will be registered as authentication providers in Medusa.

### h. Add Module Provider to Medusa's Configurations

Once you finish building the module, add it to Medusa's configurations to start using it.

In `medusa-config.ts`, add a `modules` property:

```ts title="medusa-config.ts"
// other imports...
import { Modules, ContainerRegistrationKeys } from '@medusajs/framework/utils'

module.exports = defineConfig({
  // ...
  modules: [
    {
      resolve: "@medusajs/medusa/auth",
      dependencies: [
        Modules.CACHE, 
        ContainerRegistrationKeys.LOGGER, 
        Modules.EVENT_BUS
      ],
      options: {
        providers: [
          // default provider
          {
            resolve: "@medusajs/medusa/auth-emailpass",
            id: "emailpass",
          },
          {
            resolve: "./src/modules/phone-auth",
            id: "phone-auth",
            options: {
              jwtSecret: process.env.PHONE_AUTH_JWT_SECRET || "supersecret",
            },
          },
        ],
      },
    },
  ]
})
```

To pass a Auth Module Provider to the Auth Module, you add the `modules` property to the Medusa configuration and pass the Auth Module in its value.

The Auth Module accepts a `providers` option, which is an array of Auth Module Providers to register. You register the `emailpass` provider, which is registrated by default when you don't provide any other providers.

Each provider is an object with the following properties:

- `resolve`: The path to the module provider. In this case, it's the path to the `src/modules/phone-auth` directory.
- `id`: The ID of the module provider. The auth provider is then registered with the ID `au_{id}`.
- `options`: The options to pass to the module provider. These are the options you defined in the `Options` interface of the module provider's service.

### i. Enable Phone Authentication for Customers

By default, customers and admin users can be authenticated using the `emailpass` provider. When you add a new provider, you need to specify which actor types can use it.

In `medusa-config.ts`, add to `projectConfig.http` a new `authMethodsPerActor` property:

```ts title="medusa-config.ts"
module.exports = defineConfig({
  projectConfig: {
    // ...
    http: {
      // ...
      authMethodsPerActor: {
        user: ["emailpass"],
        customer: ["emailpass", "phone-auth"],
      },
    }
  },
  // ...
})
```

The `authMethodsPerActor` property is an object whose keys are actor types. The values are arrays of authentication method IDs that can be used for that actor type.

In this case, you enable the `phone-auth` provider for customers. You can also enable it for other actor types, such as admin users or vendors.

### Test Out Phone Authentication

In this section, you'll test out the Phone Authentication Module Provider using Medusa's API routes. You can, instead, skip to later sections to test it out using the [Next.js Starter Storefront](#step-4-use-phone-authentication-in-the-nextjs-starter-storefront).

First, start the Medusa application with the following command:

```bash npm2yarn
npm run start
```

#### Prerequisite: Retrieve Publishable API Key

Before you start testing the authentication provider using the API routes, you need to retrieve your application's publishable API key. This key is necessary to send requests to API routes starting wit `/store`.

To retrieve the publishable API key:

1. Open the Medusa Admin dashboard at `http://localhost:9000/admin` and log in.
2. Go to Settings -> Publishable API Keys.
3. Click on the API key in the table.
4. In its details page, click on the API key to copy it.

![Publishable API Key page with the API key clicked](https://res.cloudinary.com/dza7lstvk/image/upload/fl_lossy/f_auto/r_16/ar_16:9,c_pad/v1/User%20Guide/Screenshot_2025-02-25_at_6.14.15_PM_muwq9e.png)

#### a. Retrieve Registration Token

The first step is to retrieve a registration token for a new customer. This token will allow them to register in the application.

To retrieve the registration token, send a `POST` request to `/auth/customer/phone-auth/register`:

```bash
curl -X POST 'http://localhost:9000/auth/customer/phone-auth/register' \
--header 'Content-Type: application/json' \
--data '{
    "phone": "+19077890116"
}'
```

Make sure to replace the phone number with the one you want to use.

This will return a `token` in the response:

```json title="Example Response"
{
  "token": "123..."
}
```

#### b. Register Customer

Next, you'll register the customer using the [Register Customer](!api!/store#customers_postcustomers) API route. You'll pass the registration token you received in the previous step in the header of this request.

So, send a `POST` request to `/store/customers`:

```bash
curl -X POST 'http://localhost:9000/store/customers' \
--header 'x-publishable-api-key: {publishable_api_key}' \
--header 'Content-Type: application/json' \
--header 'Authorization: Bearer {reg_token}' \
--data-raw '{
    "email": "+19077890116@gmail.com",
    "phone": "19077890116",
    "first_name": "John",
    "last_name": "Smith"
}'
```

Make sure to replace:

- `{publishable_api_key}` with the publishable API key you retrieved from the Medusa Admin dashboard.
- `{reg_token}` with the registration token you received in the previous step.
- The customer details in the request body with the ones you want to use. Use the same phone number you used in the previous step.
    - You pass the email because it's required by the [Register Customer](!api!/store#customers_postcustomers) API route. You set it to the phone number with a `gmail.com` domain.

The request will return the created customer's details:

```json title="Example Response"
{
    "customer": {
        "id": "cus_01JVPESW5SM1MSVPNM2MSC0ZEC",
        "email": "+19077890116@gmail.com",
        "company_name": null,
        "first_name": "John",
        "last_name": "Smith",
        "phone": "19077890116",
        "metadata": null,
        "has_account": true,
        "deleted_at": null,
        "created_at": "2025-05-20T09:01:13.273Z",
        "updated_at": "2025-05-20T09:01:13.273Z",
        "addresses": []
    }
}
```

The customer can now authenticate using the phone number and OTP.

#### c. Authenticate Customer

Next, you'll authenticate the customer using the [Authenticate Customer](!api!/store#auth_postactor_typeauth_provider) API route. This would send the customer an OTP to their phone number (which you'll implement in the next step).

So, send a `POST` request to `/auth/customer/phone-auth`:

```bash
curl -X POST 'http://localhost:9000/auth/customer/phone-auth' \
--header 'Content-Type: application/json' \
--data '{
    "phone": "+19077890116"
}'
```

Make sure to replace the phone number with the one you used to register the customer.

This will return a `location` in the response:

```json title="Example Response"
{
  "location": "otp"
}
```

Indicating that the user should verify their OTP.

<Note>

You can also use this route to resend the OTP if the user didn't receive it or if a minute has passed since the last OTP was sent.

</Note>

#### d. Verify OTP

If you check the logs of the Medusa application, you'll see that the OTP was generated and logged:

```bash
info:    Generated OTP: 576794
```

As mentioned before, this is only for debugging purposes. In the next step, you'll implement the logic to send the OTP to the user using Twilio SMS.

So, to verify the OTP, you'll send a request to the [Verify Callback API route](!api!/store#auth_postactor_typeauth_providercallback):

```bash
curl --X POST 'http://localhost:9000/auth/customer/phone-auth/callback?phone=%2B19077890116&otp=476588'
```

You pass the following query parameters:

- `phone`: The phone number of the customer. Make sure to use the same phone number you used to register the customer, and to encode it. For example, the `+` sign should be encoded as `%2B`.
- `otp`: The OTP that the customer received. Make sure to use the same OTP shown in the logs.

If the OTP is valid, you'll receive a JWT token in the response:

```json title="Example Response"
{
  "token": "123..."
}
```

You can use this token to authenticate the customer in the application. For example, you can use the token to [retrieve the customer's details](!api!/store#customers_getcustomersme).

<Note>

If the OTP has expired, send a request to the [Authenticate Customer](#c-authenticate-customer) API route to generate a new OTP

</Note>

---

## Step 3: Integrate Twilio SMS

Similar to the Auth Module, the [Notification Module](../../../infrastructure-modules/notification/page.mdx) allows registering custom providers to send notifications, such as SMS or email.

In this step, you'll create a Twilio Notification Module Provider, then use it to send the OTP to the customer.

<Prerequisites
  items={[
    {
      text: "Twilio Account",
      link: "https://console.twilio.com/"
    },
    {
      text: "Twilio From Phone Number",
      link: "https://www.twilio.com/docs/phone-numbers"
    },
    {
      text: "Twilio Account SID, which you can retrieve from the Twilio Console homepage.",
      link: "https://www.twilio.com/docs/usage/tutorials/how-to-use-your-free-trial-account-namer#console-dashboard-home-page"
    },
    {
      text: "Twilio Auth Token, which you can retrieve from the Twilio Console homepage.",
      link: "https://www.twilio.com/docs/usage/tutorials/how-to-use-your-free-trial-account-namer#console-dashboard-home-page"
    }
  ]}
/>

### a. Install Twilio SDK

Before you start implementing the Twilio Notification Module Provider, install the Twilio SDK to interact with the Twilio API.

```bash npm2yarn
npm install twilio
```

You'll use the Twilio SDK in the Notification Module Provider's service.

### b. Create Module Directory

Create the directory `src/modules/twilio-sms` to create the Twilio Notification Module Provider.

### c. Create Notification Module Provider Service

A Notification Module Provider has a service that contains the sending logic. The service must extend the `AbstractNotificationProviderService` class.

So, create the file `src/modules/twilio-sms/service.ts` with the following content:

```ts title="src/modules/twilio-sms/service.ts"
import { 
  AbstractNotificationProviderService
} from "@medusajs/framework/utils"

type InjectedDependencies = {}

type TwilioSmsServiceOptions = {
  accountSid: string
  authToken: string
  from: string
}

class TwilioSmsService extends AbstractNotificationProviderService {
  static readonly identifier = "twilio-sms"
  private readonly client: Twilio
  private readonly from: string

  constructor(container: InjectedDependencies, options: TwilioSmsServiceOptions) {
    super()

    this.client = new Twilio(options.accountSid, options.authToken)
    this.from = options.from
  }
}
```

You'll get a type error about implementing the abstract methods of the `AbstractNotificationProviderService` class, which you'll add in the next steps.

A Notification Module Provider must an `identifier`, which is a unique identifier for the module. This identifier is used to register the module in the Medusa application.

A module provider's constructor receives two parameters:

- `container`: The [module's container](!docs!/learn/fundamentals/modules/container) that contains Framework resources available to the module. You don't need to access any resources for this tutorial.
- `options`: Options that are passed to the module provider when it's registered in Medusa's configurations. You define the following option:
    - `accountSid`: The Twilio account SID.
    - `authToken`: The Twilio auth token.
    - `from`: The Twilio phone number to send the SMS from.

<Note>

You'll learn how to set these options when you [add the module provider to Medusa's configurations](#g-add-module-provider-to-medusas-configurations).

</Note>

In the constructor, you set the class's properties to the injected dependencies and options.

In the next sections, you'll implement the methods of the `AbstractNotificationProviderService` class.

<Note>

Refer to the [Create Notification Module Provider](/references/notification-provider-module) guide for detailed information about the methods.

</Note>

### d. Implement validateOptions Method

The `validateOptions` method is used to validate the options passed to the module provider. If the method throws an error, the Medusa application won't start.

So, add the `validateOptions` method to the `TwilioSmsService` class:

```ts title="src/modules/twilio-sms/service.ts"
class TwilioSmsService extends AbstractNotificationProviderService {
  // ...
  static validateOptions(options: Record<any, any>): void | never {
    if (!options.accountSid) {
      throw new Error("Account SID is required")
    }
    if (!options.authToken) {
      throw new Error("Auth token is required")
    }
    if (!options.from) {
      throw new Error("From is required")
    }
  }
}
```

The `validateOptions` method receives the options passed to the module provider as a parameter.

In the method, you throw an error if any of the options are not set.

### e. Implement send Method

The only required method for a Notification Module Provider is the `send` method. When the Medusa application needs to send a notification using the provider's channel (such as SMS), it calls this method of the registered provider.

So, add the `send` method to the `TwilioSmsService` class:

```ts title="src/modules/twilio-sms/service.ts"
// other imports...
import { 
  ProviderSendNotificationDTO, 
  ProviderSendNotificationResultsDTO
} from "@medusajs/types"

class TwilioSmsService extends AbstractNotificationProviderService {
  // ...
  async send(notification: ProviderSendNotificationDTO): Promise<ProviderSendNotificationResultsDTO> {
    const { to, content, template, data } = notification
    const templateContent = await this.getTemplateContent(template, data)
    const contentText = content?.text || templateContent

    const message = await this.client.messages.create({
      body: contentText,
      from: this.from,
      to
    })

    return {
      id: message.sid,
    }
  }

  async getTemplateContent(template: string, data?: Record<string, unknown> | null): Promise<string> {
    switch (template) {
      case "otp-template":
        if (!data?.otp) {
          throw new Error("OTP is required for OTP template")
        }

        return `Your OTP is ${data.otp}`
      default:
        throw new Error(`Template ${template} not found`)
    }
  }
}
```

You implement the `send` method and a helper `getTemplateContent` method.

#### send Parameters

The `send` method receives an object parameter with the following properties:

- `to`: The phone number to send the SMS to.
- `content`: An object containing the content of the SMS. The `text` property is the text to send.
- `template`: The template to use for the SMS. This is used to retrieve the content of the SMS if none is provided in the `content` property.
- `data`: An object containing the data to use in the template. This is used to replace placeholders in the template with actual values.

<Note>

The method receives other parameters, which you can find in the [Create Notification Module Provider](/references/notification-provider-module#send) guide.

</Note>

#### send Method Logic

In the method, you set the SMS content either to the `text` property of the `content` object or to the template content. You define a `getTemplateContent` method that retrieves the content for a template.

Then, you use the `messages.create` method of the Twilio client to send the SMS. You pass the following parameters:

- `body`: The content of the SMS.
- `from`: The Twilio phone number to send the SMS from.
- `to`: The phone number to send the SMS to.

#### send Return Value

Finally, you return an object that has an `id` property with the ID of the sent SMS. This ID is stored in the notification record in the database.

### f. Export Module Definition

You've now finished implementing the necessary methods for the Twilio Notification Module Provider.

The final piece to a module is its definition, which you export in an `index.ts` file at the module's root directory. This definition tells Medusa the name of the module, its service, and optionally its loaders.

To create the module's definition, create the file `src/modules/twilio-sms/index.ts` with the following content:

```ts title="src/modules/twilio-sms/index.ts"
import { 
  ModuleProvider, 
  Modules,
} from "@medusajs/framework/utils"
import TwilioSMSNotificationService from "./service"

export default ModuleProvider(Modules.NOTIFICATION, {
  services: [TwilioSMSNotificationService],
})
```

You use `ModuleProvider` from the Modules SDK to create the module provider's definition. It accepts two parameters:

1. The name of the module that this provider belongs to, which is `Modules.NOTIFICATION` in this case.
2. An object with a required property `services` indicating the module provider's services. Each of these services will be registered as notification providers in Medusa.

### g. Add Module Provider to Medusa's Configurations

You'll now add the Twilio Notification Module Provider to Medusa's configurations to start using it.

In `medusa-config.ts`, add the following to the `modules` property:

```ts title="medusa-config.ts"
module.exports = defineConfig({
  // ...
  modules: [
    // ...
    {
      resolve: "@medusajs/medusa/notification",
      options: {
        providers: [
          // default provider
          {
            resolve: "@medusajs/medusa/notification-local",
            id: "local",
            options: {
              name: "Local Notification Provider",
              channels: ["feed"],
            },
          },
          {
            resolve: "./src/modules/twilio-sms",
            id: "twilio-sms",
            options: {
              channels: ["sms"],
              accountSid: process.env.TWILIO_ACCOUNT_SID,
              authToken: process.env.TWILIO_AUTH_TOKEN,
              from: process.env.TWILIO_FROM,
            },
          },
        ],
      },
    }
  ]
})
```

You pass the Notification Module in the `modules` property to register the Twilio Notification Module Provider.

The Notification Module accepts a `providers` option, which is an array of Notification Module Providers to register. You register the `local` provider, which is registrated by default when you don't provide any other providers.

Each provider is an object with the following properties:

- `resolve`: The path to the module provider. In this case, it's the path to the `src/modules/twilio-sms` directory.
- `id`: The ID of the module provider. The notification provider is then registered with the ID `nt_{id}`.
- `options`: The options to pass to the module provider. These are the options you defined in the `Options` interface of the module provider's service.
    - `channels`: The channels that the notification provider supports. In this case, you set it to `sms`, which is the channel used to send SMS notifications.
    - `accountSid`: The Twilio account SID.
    - `authToken`: The Twilio auth token.
    - `from`: The Twilio phone number to send the SMS from.

### h. Add Environment Variables

To set the value of the Twilio options, add the following environment variables to your `.env` file:

```shell title=".env"
TWILIO_ACCOUNT_SID=AC...
TWILIO_AUTH_TOKEN=05...
TWILIO_FROM=+1...
```

Where:

- `TWILIO_ACCOUNT_SID`: The Twilio account SID.
- `TWILIO_AUTH_TOKEN`: The Twilio auth token.
- `TWILIO_FROM`: The Twilio phone number to send the SMS from. Make sure to use the phone number you purchased from Twilio.

You can retrieve these information from the Twilio Console homepage.

![Twilio console homepage showing the account SID, phone number, and auth token](https://res.cloudinary.com/dza7lstvk/image/upload/v1747736641/Medusa%20Resources/CleanShot_2025-05-20_at_13.22.55_2x_sztmfo.png)

### i. Handle OTP Generated Event

Now that you have integrated Twilio into Medusa, you can use it to send the OTP to the customer. To do that, you need to handle the `phone-auth.otp.generated` event that you emitted in the `authenticate` method of the Phone Authentication Module Provider.

You can listen to events in a [subscriber](!docs!/learn/fundamentals/events-and-subscribers). A subscriber is an asynchronous function that listens to events to perform actions when the event is emitted.

In this step, you'll create a subscriber that listens to the `order.placed` event and executes the `handleOrderPointsWorkflow` workflow.

<Note>

Refer to the [Events and Subscribers](!docs!/learn/fundamentals/events-and-subscribers) documentation to learn more.

</Note>

Subscribers are created in a TypeScript or JavaScript file under the `src/subscribers` directory. So, to create a subscriber, create the file `src/subscribers/send-otp.ts` with the following content:

```ts title="src/subscribers/send-otp.ts"
import {
  SubscriberArgs,
  type SubscriberConfig,
} from "@medusajs/medusa"
import { Modules } from "@medusajs/framework/utils"

export default async function sendOtpHandler({
  event: { data: {
    phone,
    otp,
  } },
  container,
}: SubscriberArgs<{ phone: string, otp: string }>) {
  const notificationModuleService = container.resolve(
    Modules.NOTIFICATION
  )

  await notificationModuleService.createNotifications({
    to: phone,
    channel: "sms",
    template: "otp-template",
    data: {
      otp,
    },
  })
}

export const config: SubscriberConfig = {
  event: "phone-auth.otp.generated",
}
```

The subscriber file must export:

- An asynchronous subscriber function that's executed whenever the associated event is triggered.
- A configuration object with an event property whose value is the event the subscriber is listening to, which is `phone-auth.otp.generated`.

The subscriber function accepts an object with the following properties:

- `event`: An object with the event's data payload. In the `authenticate` method, you emitted the event with the following data:
    - `phone`: The phone number of the user.
    - `otp`: The OTP that was generated.
- `container`: The [Medusa container](!docs!/learn/fundamentals/medusa-container), which you can use to resolve Framework and Commerce resources.

In the subscriber function, you resolve the Notification Module's service from the Medusa container. Then, you use its `createNotifications` method to send the OTP to the user.

Under the hood, the Notification Module's service delegates the sending to the Notification Module Provider of the `sms` channel, which is the Twilio Notification Module Provider in this case.

The `createNotifications` method accepts an object with the following properties:

- `to`: The phone number to send the SMS to. You use the phone number from the event's data payload.
- `channel`: The channel to use to send the SMS, which is `sms`.
- `template`: The template to use for the SMS content, which is `otp-template`.
- `data`: An object containing the data to use in the template. You pass the OTP code to the template.

### j. Test it Out

To test out the Twilio Notification Module Provider, you can follow the steps in the [Test Out Phone Authentication](#test-out-phone-authentication) section.

After you authenticate the customer, the OTP will be sent to the customer's phone number using Twilio SMS. Then, you can use the OTP to verify the authentication and receive a JWT token.

Alternatively, you can also test it out after customizing the Next.js Starter Storefront, which you'll do in the next step.

<Note>

Make sure to remove the OTP logging line in the `generateOTP` method now that you have integrated Twilio SMS.

</Note>

---

## Step 4: Use Phone Authentication in the Next.js Starter Storefront

In this step, you'll customize the [Next.js Starter Storefront](../../../nextjs-starter/page.mdx) to allow customers to authenticate using their phone number and OTP.

By default, the Next.js Starter Storefront supports email and password authentication. You'll replace it with phone authentication, but you can also keep both authentication methods if you want to.

<Note title="Reminder" forceMultiline>

The Next.js Starter Storefront was installed in a separate directory from Medusa. The directory's name is `{your-project}-storefront`.

So, if your Medusa application's directory is `medusa-phone-auth`, you can find the storefront by going back to the parent directory and changing to the `medusa-phone-auth-storefront` directory:

```bash
cd ../medusa-phone-auth-storefront # change based on your project name
```

</Note>

### a. Install Phone Input Package

To easily show a phone input where the user can enter their phone number, install the `react-phone-number-input` package:

```bash npm2yarn
npm install react-phone-number-input
```

You'll use it in the login and registration forms to show a phone input.

### b. Add Authenticate Function

Before adding the forms, you'll add the functions that send requests to the Medusa API to authenticate the customer.

The first one you'll add is the `authenticateWithPhone` function, which sends a request to the `/auth/customer/phone-auth` API route to authenticate the customer using their phone number.

In `src/lib/data/customer.ts`, add the following function:

```ts title="src/lib/data/customer.ts" badgeLabel="Storefront" badgeColor="blue"
export const authenticateWithPhone = async (phone: string) => {
  try {
    const response = await sdk.auth.login("customer", "phone-auth", {
      phone
    })

    if (typeof response === "string" || !response.location || response.location !== "otp") {
      throw new Error("Failed to login")
    }

    return true
  } catch (error: any) {
    return error.toString()
  }
}
```

The function accepts the phone number as a parameter.

In the function, you use the [JS SDK](../../../js-sdk/page.mdx), which is configured within the Next.js Starter Storefront, to send a request to the `/auth/customer/phone-auth` API route. You pass the phone number in the request body.

If the request desn't return a `location` property set to `otp`, you throw an error. Otherwise, you return `true` to indicate that the request was successful.

### c. add Verify OTP Function

Next, you'll add the `verifyOTP` function, which sends a request to the `/auth/customer/phone-auth/callback` API route to verify the OTP.

In `src/lib/data/customer.ts`, add the following function:

```ts title="src/lib/data/customer.ts" badgeLabel="Storefront" badgeColor="blue"
export const verifyOtp = async ({
  otp,
  phone,
}: {
  otp: string
  phone: string
}) => {
  try {
    const token = await sdk.auth.callback("customer", "phone-auth", {
      phone,
      otp,
    })

    await setAuthToken(token)

    const customerCacheTag = await getCacheTag("customers")
    revalidateTag(customerCacheTag)

    await transferCart()

    return true
  } catch (e: any) {
    return e.toString()
  }  
}
```

The function accepts an object with the following properties:

- `otp`: The OTP to verify.
- `phone`: The phone number of the customer.

In the function, you use the JS SDK to send a request to the `/auth/customer/phone-auth/callback` API route. You pass the phone number and OTP in the request body.

If the request is successful and you receive a token, you set the token as the authentication token an refresh the customer cache tag. This ensures that all customer-related UI is updated after logging in, such as showing the customer's profile when accessing the `/account` page.

Then, you call the `transferCart` function to transfer the cart from the guest user to the authenticated customer.

Finally, you return `true` to indicate that the request was successful.

### d. Add Registration Function

The last function you'll add is the `registerWithPhone` function, which will register the customer using their phone number.

In `src/lib/data/customer.ts`, add the following function:

```ts title="src/lib/data/customer.ts" badgeLabel="Storefront" badgeColor="blue"
export const registerWithPhone = async ({
  firstName,
  lastName,
  phone,
}: {
  firstName: string
  lastName: string
  phone: string
}) => {
  try {
    const { token: regToken } = await sdk.client.fetch<{ token: string }>(`/auth/customer/phone-auth/register`, {
      method: "POST",
      body: {
        phone,
      },
    })
    
    await setAuthToken(regToken as string)
    const headers = {
      ...(await getAuthHeaders()),
    }

    const email = `${phone}@gmail.com`
    const customerForm = {
      email,
      first_name: firstName,
      last_name: lastName,
      phone,
    }
    
    await sdk.store.customer.create(
      customerForm,
      {},
      headers
    )

    return await authenticateWithPhone(phone)
  } catch (error: any) {
    return error.toString()
  }
}
```

The function accepts an object with the following properties:

- `firstName`: The first name of the customer.
- `lastName`: The last name of the customer.
- `phone`: The phone number of the customer.

In the function, you retrieve a registration token for the customer using the `/auth/customer/phone-auth/register` API route. You pass the phone number in the request body.

Then, after setting the registration token as the authentication token, you create a customer using the [Create Customer](!api!/store#customers_postcustomers) API route. You pass the following properties in the request body:

- `email`: The email of the customer. You set it to the phone number with a `@gmail.com` domain.
- `first_name`: The first name of the customer.
- `last_name`: The last name of the customer.
- `phone`: The phone number of the customer.

Finally, you call the `authenticateWithPhone` function to authenticate the customer using their phone number. At this step, the customer would receive an OTP to login.

### e. Add OTP Form

Next, you'll add an OTP form that allows the customer to enter the OTP they receive after login or registration. Later, you'll reuse this form in both the login and registration pages.

Create the file `src/modules/account/components/otp/index.tsx` with the following content:

```tsx title="src/modules/account/components/otp/index.tsx" badgeLabel="Storefront" badgeColor="blue"
"use client"

import { Input } from "@medusajs/ui"
import { useState, useRef, useEffect } from "react"
import { authenticateWithPhone, verifyOtp } from "../../../../lib/data/customer"
import ErrorMessage from "../../../checkout/components/error-message"

type Props = {
  phone: string
}

export const Otp = ({ phone }: Props) => {
  const [otp, setOtp] = useState<string>("")
  const [error, setError] = useState<string>("")
  const [isLoading, setIsLoading] = useState<boolean>(false)
  const [countdown, setCountdown] = useState<number>(60)
  const inputRefs = useRef<(HTMLInputElement | null)[]>([])

  const handleSubmit = async () => {
    setIsLoading(true)
    const response = await verifyOtp({
      otp,
      phone,
    })
    setOtp("")
    setIsLoading(false)

    if (typeof response === "string") {
      setError(response)
    }
  }

  const handleResend = async () => {
    authenticateWithPhone(phone)
    setCountdown(60)
  }

  const handlePaste = (e: React.ClipboardEvent) => {
    e.preventDefault()
    const pastedData = e.clipboardData.getData("text")
    const numericValue = pastedData.replace(/\D/g, "").slice(0, 6)
    
    if (numericValue) {
      setOtp(numericValue)
      // Focus the next empty input after pasted content
      const nextEmptyIndex = Math.min(numericValue.length, 5)
      inputRefs.current[nextEmptyIndex]?.focus()
    }
  }

  // TODO add use effects
}
```

You create an `Otp` component that accepts the phone number as a prop.

In the component, you define the following state variables:

- `otp`: The OTP entered by the customer.
- `error`: The error message to show if the OTP verification fails.
- `isLoading`: A boolean indicating whether the OTP verification is in progress.
- `countdown`: The countdown timer for resending the OTP.
- `inputRefs`: A ref to store the input elements for the OTP digits. You'll show six input elements for the OTP digits.

You also define the following functions:

- `handleSubmit`: This function is called when the customer submits the OTP. It calls the `verifyOtp` function to verify the OTP entered by the customer.
- `handleResend`: This function is called when the customer clicks the "Resend OTP" button that you'll add later. It calls the `authenticateWithPhone` function to resend the OTP to the customer's phone number.
- `handlePaste`: This function is called when the customer pastes the OTP in the input field. It improves the experience of pasting the OTP without having to enter it manually.

#### Handle Variable Changes

Next, you'll add `useEffect` hooks to handle changes in the state variables.

Replace the `TODO` with the following:

```tsx title="src/modules/account/components/otp/index.tsx" badgeLabel="Storefront" badgeColor="blue"
useEffect(() => {
  if (inputRefs.current[0]) {
    inputRefs.current[0].focus()
  }
}, [inputRefs.current])

useEffect(() => {
  if (otp.length !== 6 || isLoading) {
    return
  }

  handleSubmit()
}, [otp, isLoading])

useEffect(() => {
  const timer = setInterval(() => {
    setCountdown((prev) => (prev > 0 ? prev - 1 : 0))
  }, 1000)

  return () => clearInterval(timer)
}, [])

// TODO render form
```

You add three `useEffect` hooks:

1. The first one focuses the first input element when the component mounts.
2. The second one automatically submits the OTP when the customer enters six digits.
3. The third one adds an interval to update the countdown timer every second.

### f. Render OTP Form

Lastly, you'll render the OTP form with the input elements and the resend button.

Replace the `TODO` with the following:

```tsx title="src/modules/account/components/otp/index.tsx" badgeLabel="Storefront" badgeColor="blue"
return (
  <div
    className="max-w-sm flex flex-col items-center"
    data-testid="otp-page"
  >
    <h1 className="text-large-semi uppercase mb-6">
      Verify Phone Number
    </h1>
    <p className="text-center text-base-regular text-ui-fg-base mb-4">
      Enter the code sent to your phone number to verify your account.
    </p>
    <div className="flex gap-2 mb-4">
      {[...Array(6)].map((_, index) => (
        <Input
          key={index}
          type="text"
          maxLength={1}
          pattern="\d*"
          inputMode="numeric"
          disabled={isLoading}
          className="w-10 h-10 text-center"
          ref={(el) => {
            inputRefs.current[index] = el
          }}
          onPaste={handlePaste}
          value={otp[index] || ""}
          onChange={(e) => {
            const elm = e.target
            const value = elm.value
            setOtp((prev) => {
              const newOtp = prev.split("")
              newOtp[index] = value
              return newOtp.join("")
            })
            if (value && /^\d+$/.test(value)) {
              // Move focus to next input
              const nextInput = elm.parentElement?.nextElementSibling?.querySelector("input")
              nextInput?.focus()
            }
          }}
          onKeyDown={(e) => {
            if (e.key === "Backspace" && !e.currentTarget.value) {
              // Move focus to previous input on backspace
              const prevInput = e.currentTarget.parentElement?.previousElementSibling?.querySelector("input")
              prevInput?.focus()
            }
          }}
        />
      ))}        
    </div>
    <div className="flex items-center gap-x-2 mb-4">
      <button
        className="text-small-regular text-ui-fg-interactive disabled:text-ui-fg-disabled disabled:cursor-not-allowed"
        onClick={handleResend}
        disabled={countdown > 0}
      >
        {countdown > 0 ? `Resend code in ${countdown}s` : "Resend Code"}
      </button>
    </div>
    <ErrorMessage error={error} />
  </div>
)
```

You show six input elements for the OTP digits. When a value is entered in an input, the focus moves to the next input. 

You also show a resend button that allows the customer to resend the OTP once the countdown timer reaches zero.

You now have an OTP form that you can use in both the login and registration pages.

### g. Add Registration Form

You'll now add a registration form that allows the customer to register using their phone number.

First, in `src/modules/account/templates/login-template.tsx`, update the `LOGIN_VIEW` to the following:

```tsx title="src/modules/account/templates/login-template.tsx" badgeLabel="Storefront" badgeColor="blue"
export enum LOGIN_VIEW {
  SIGN_IN = "sign-in",
  REGISTER = "register",
  REGISTER_PHONE = "register-phone",
  SIGN_IN_PHONE = "sign-in-phone",
}
```

By default, the login template supports switching between the login and registration views for email and password authentication. You now added two new views: login and registration with phone number.

Then, to add the registration form, create the file `src/modules/account/components/register-phone/index.tsx` with the following content:

```tsx title="src/modules/account/components/register-phone/index.tsx" badgeLabel="Storefront" badgeColor="blue"
"use client"

import { useState } from "react"
import Input from "@modules/common/components/input"
import { LOGIN_VIEW } from "@modules/account/templates/login-template"
import ErrorMessage from "@modules/checkout/components/error-message"
import LocalizedClientLink from "@modules/common/components/localized-client-link"
import { registerWithPhone } from "@lib/data/customer"
import 'react-phone-number-input/style.css'
import PhoneInput from 'react-phone-number-input'
import { Otp } from "../otp"
import { useParams } from "next/navigation"
import { Button } from "@medusajs/ui"

type Props = {
  setCurrentView: (view: LOGIN_VIEW) => void
}

const RegisterPhone = ({ setCurrentView }: Props) => {
  const [firstName, setFirstName] = useState("")
  const [lastName, setLastName] = useState("")
  const [phone, setPhone] = useState("")
  const [error, setError] = useState("")
  const [loading, setLoading] = useState(false)
  const [enterOtp, setEnterOtp] = useState(false)
  const { countryCode } = useParams() as { countryCode: string }

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    setLoading(true)
    const response = await registerWithPhone({
      firstName,
      lastName,
      phone,
    })
    setLoading(false)
    if (typeof response === "string") {
      setError(response)
      return
    }

    setEnterOtp(true)
  }

  if (enterOtp) {
    return <Otp phone={phone} />
  }

  // TODO render form
}

export default RegisterPhone
```

You create a `RegisterPhone` component that accepts a `setCurrentView` prop to switch between the login and registration views.

In the component, you define the following state variables:

- `firstName`, `lastName`, and `phone` to store the form inputs' values.
- `error`: The error message to show if the registration fails.
- `loading`: A boolean indicating whether the registration is in progress.
- `enterOtp`: A boolean indicating whether to show the OTP form. This is enabled once the customer is registered and they need to authenticate using the OTP.
- `countryCode`: The country code of the customer, which is retrieved from the URL parameters. You'll use this to show the phone input with a default selected country.

You also define a `handleSubmit` function that handles the form submission. It calls the `registerWithPhone` function to register the customer using their phone number.

If the registration is successful, you set `enterOtp` to `true` to show the OTP form. Otherwise, you set the error message.

#### Render Registration Form

Next, you'll render the registration form with the input fields and the submit button.

Replace the `TODO` with the following:

```tsx title="src/modules/account/components/register-phone/index.tsx" badgeLabel="Storefront" badgeColor="blue"
return (
  <div
    className="max-w-sm flex flex-col items-center"
    data-testid="register-page"
  >
    <h1 className="text-large-semi uppercase mb-6">
      Become a Medusa Store Member
    </h1>
    <p className="text-center text-base-regular text-ui-fg-base mb-4">
      Create your Medusa Store Member profile, and get access to an enhanced
      shopping experience.
    </p>
    <form className="w-full flex flex-col" onSubmit={handleSubmit}>
      <div className="flex flex-col w-full gap-y-2">
        <Input
          label="First name"
          name="first_name"
          required
          autoComplete="given-name"
          data-testid="first-name-input"
          value={firstName}
          onChange={(e) => setFirstName(e.target.value)}
        />
        <Input
          label="Last name"
          name="last_name"
          required
          autoComplete="family-name"
          data-testid="last-name-input"
          value={lastName}
          onChange={(e) => setLastName(e.target.value)}
        />
        <PhoneInput
          placeholder="Enter phone number"
          value={phone}
          onChange={(value) => setPhone(value as string)}
          name="phone"
          required
          autoComplete="off"
          // @ts-ignore
          defaultCountry={countryCode.toUpperCase()}
        />
      </div>
      <ErrorMessage error={error} data-testid="register-error" />
      <span className="text-center text-ui-fg-base text-small-regular mt-6">
        By creating an account, you agree to Medusa Store&apos;s{" "}
        <LocalizedClientLink
          href="/content/privacy-policy"
          className="underline"
        >
          Privacy Policy
        </LocalizedClientLink>{" "}
        and{" "}
        <LocalizedClientLink
          href="/content/terms-of-use"
          className="underline"
        >
          Terms of Use
        </LocalizedClientLink>
        .
      </span>
      <Button 
        className="w-full mt-6" 
        type="submit"
        size="large"
        variant="primary"
        isLoading={loading}
      >
        Join
      </Button>
    </form>
    <span className="text-center text-ui-fg-base text-small-regular mt-6">
      Already a member?{" "}
      <button
        onClick={() => setCurrentView(LOGIN_VIEW.SIGN_IN_PHONE)}
        className="underline"
      >
        Sign in
      </button>
      .
    </span>
  </div>
)
```

You render the registration form with input fields for the first name, last name, and phone number.

For the phone number input, you use the `PhoneInput` component from the `react-phone-number-input` package. You set the `defaultCountry` prop to the country code retrieved from the URL parameters.

You also show a submit button that calls the `handleSubmit` function when clicked, and a button to switch to the login form.

#### Add to Login Template

Next, you'll add the `RegisterPhone` component to the login template.

In `src/modules/account/templates/login-template.tsx`, add the following import:

```tsx title="src/modules/account/templates/login-template.tsx" badgeLabel="Storefront" badgeColor="blue"
import RegisterPhone from "@modules/account/components/register-phone"
```

Then, change the `return` statement of the `LoginTemplate` component to the following:

```tsx title="src/modules/account/templates/login-template.tsx" badgeLabel="Storefront" badgeColor="blue"
return (
  <div className="w-full flex justify-start px-8 py-8">
    {currentView === "sign-in" ? (
      <Login setCurrentView={setCurrentView} />
    ) : currentView === "register" ? (
      <Register setCurrentView={setCurrentView} />
    ) : currentView === "register-phone" ? (
      <RegisterPhone setCurrentView={setCurrentView} />
    ) : (
      // TODO: Add login phone view
      <></>
    )}
  </div>
)
```

You show the registration form when the `currentView` is set to `register-phone`. You'll also add the login form later.

### h. Add Login Form

Next, you'll add a login form that allows the customer to log in using their phone number.

To create the form, create the file `src/modules/account/components/login-phone/index.tsx` with the following content:

```tsx title="src/modules/account/components/login-phone/index.tsx" badgeLabel="Storefront" badgeColor="blue"
"use client"

import { authenticateWithPhone } from "@lib/data/customer"
import { LOGIN_VIEW } from "@modules/account/templates/login-template"
import ErrorMessage from "@modules/checkout/components/error-message"
import { useState } from "react"
import 'react-phone-number-input/style.css'
import PhoneInput from 'react-phone-number-input'
import { Otp } from "../otp"
import { useParams } from "next/navigation"
import { Button } from "@medusajs/ui"

type Props = {
  setCurrentView: (view: LOGIN_VIEW) => void
}

const LoginPhone = ({ setCurrentView }: Props) => {
  const [phone, setPhone] = useState("")
  const [error, setError] = useState("")
  const [loading, setLoading] = useState(false)
  const [enterOtp, setEnterOtp] = useState(false)
  const { countryCode } = useParams() as { countryCode: string }

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    setLoading(true)
    const response = await authenticateWithPhone(phone)
    setLoading(false)
    if (typeof response === "string") {
      setError(response)
      return
    }

    setEnterOtp(true)
  }

  if (enterOtp) {
    return <Otp phone={phone} />
  }

  // TODO render form
}

export default LoginPhone
```

You create a `LoginPhone` component that accepts a `setCurrentView` prop to switch between the login and registration views.

In the component, you define the following state variables:

- `phone`: The phone number entered by the customer.
- `error`: The error message to show if the login fails.
- `loading`: A boolean indicating whether the login is in progress.
- `enterOtp`: A boolean indicating whether to show the OTP form. This is enabled after the form is submitted.
- `countryCode`: The country code of the customer, which is retrieved from the URL parameters. You'll use this to show the phone input with a default selected country.

You also define a `handleSubmit` function that handles the form submission. It calls the `authenticateWithPhone` function to authenticate the customer using their phone number. Then, it enables `enterOtp` to show the OTP form.

#### Render Login Form

Next, you'll render the login form with the input field and the submit button.

Replace the `TODO` with the following:

```tsx title="src/modules/account/components/login-phone/index.tsx" badgeLabel="Storefront" badgeColor="blue"
return (
  <div
    className="max-w-sm w-full flex flex-col items-center"
    data-testid="login-page"
  >
    <h1 className="text-large-semi uppercase mb-6">Welcome back</h1>
    <p className="text-center text-base-regular text-ui-fg-base mb-8">
      Sign in to access an enhanced shopping experience.
    </p>
    <form className="w-full" onSubmit={handleSubmit}>
      <div className="flex flex-col w-full gap-y-2">
        <PhoneInput
          placeholder="Enter phone number"
          value={phone}
          onChange={(value) => setPhone(value as string)}
          name="phone"
          required
          // @ts-ignore
          defaultCountry={countryCode.toUpperCase()}
        />
      </div>
      {error && <ErrorMessage error={error} data-testid="login-error-message" />}
      <Button 
        className="w-full mt-6" 
        disabled={loading}
        type="submit"
        size="large"
        variant="primary"
        isLoading={loading}
      >
        Sign in
      </Button>
    </form>
    <span className="text-center text-ui-fg-base text-small-regular mt-6">
      Not a member?{" "}
      <button
        onClick={() => setCurrentView(LOGIN_VIEW.REGISTER_PHONE)}
        className="underline"
        data-testid="register-button"
      >
        Join us
      </button>
      .
    </span>
  </div>
)
```

You render the login form with an input field for the phone number. You also show a submit button that calls the `handleSubmit` function when clicked.

### i. Add to Login Template

Next, you'll add the `LoginPhone` component to the login template.

In `src/modules/account/templates/login-template.tsx`, add the following import:

```tsx title="src/modules/account/templates/login-template.tsx" badgeLabel="Storefront" badgeColor="blue"
import LoginPhone from "../components/login-phone"
```

Next, in the `LoginTemplate` component, change the default value of the `currentView` state to `LOGIN_VIEW.SIGN_IN_PHONE`:

```tsx title="src/modules/account/templates/login-template.tsx" badgeLabel="Storefront" badgeColor="blue"
const [currentView, setCurrentView] = useState(LOGIN_VIEW.SIGN_IN_PHONE)
```

This ensures the phone login form is shown by default.

Finally, replace the `return` statement of the `LoginTemplate` component to the following:

```tsx title="src/modules/account/templates/login-template.tsx" badgeLabel="Storefront" badgeColor="blue"
return (
  <div className="w-full flex justify-start px-8 py-8">
    {currentView === "sign-in" ? (
      <Login setCurrentView={setCurrentView} />
    ) : currentView === "register" ? (
      <Register setCurrentView={setCurrentView} />
    ) : currentView === "register-phone" ? (
      <RegisterPhone setCurrentView={setCurrentView} />
    ) : (
      <LoginPhone setCurrentView={setCurrentView} />
    )}
  </div>
)
```

You show the login form when the `currentView` is set to `sign-in-phone`.

### Test it Out

You can now test out the phone authentication feature in the Next.js Starter Storefront.

First, start the Medusa application by running the following command in the Medusa project's directory:

```bash npm2yarn badgeLabel="Medusa Application" badgeColor="green"
npm run dev
```

Then, start the Next.js Starter Storefront by running the following command in the storefront project's directory:

```bash npm2yarn badgeLabel="Storefront" badgeColor="blue"
npm run dev
```

Open your browser, navigate to `http://localhost:8000`, and click on the "Account" link at the top right. This will show the login form with just the phone number input.

![Login form with phone number input](https://res.cloudinary.com/dza7lstvk/image/upload/v1747739945/Medusa%20Resources/CleanShot_2025-05-20_at_14.18.36_2x_ubuika.png)

You can also switch to the registration form by clicking on the "Join us" link.

![Registration form with phone number input](https://res.cloudinary.com/dza7lstvk/image/upload/v1747739988/Medusa%20Resources/CleanShot_2025-05-20_at_14.19.35_2x_btlc2s.png)

You can try to login with the account you created before, or register with a new one. Once successful, you'll see the OTP form to enter the OTP you received as SMS.

![OTP form](https://res.cloudinary.com/dza7lstvk/image/upload/v1747740102/Medusa%20Resources/CleanShot_2025-05-20_at_14.21.18_2x_yrkuyg.png)

After you enter the six digits, you'll be logged in and you'll see your profile page.

![Profile page](https://res.cloudinary.com/dza7lstvk/image/upload/v1747740166/Medusa%20Resources/CleanShot_2025-05-20_at_14.22.30_2x_kshb83.png)

---

## Step 5: Updates to Profile Page

The phone authentication feature is now complete, but there are two improvements you can make:

1. Show the phone number in the profile page: Currently, it shows the email address, which is a fake address you've set.
2. Disable phone and email updates: Currently, the customer can update their phone number, which is not allowed for phone authentication.

### a. Show Phone Number in Profile Page

To show the phone number in the profile page, in `src/modules/account/components/overview/index.tsx`, find the following in the `return` statement:

```tsx title="src/modules/account/components/overview/index.tsx" badgeLabel="Storefront" badgeColor="blue"
<span
  className="font-semibold"
  data-testid="customer-email"
  data-value={customer?.email}
>
  {customer?.email}
</span>
```

And replace it with the following:

```tsx title="src/modules/account/components/overview/index.tsx" badgeLabel="Storefront" badgeColor="blue"
<span
  className="font-semibold"
  data-testid="customer-phone"
  data-value={customer?.phone}
>
  {customer?.phone}
</span>
```

If you check the profile page now, you'll see the phone number instead of the email address at the top right.

![Phone number showing in profile page](https://res.cloudinary.com/dza7lstvk/image/upload/v1747740378/Medusa%20Resources/CleanShot_2025-05-20_at_14.25.59_2x_x0pxvt.png)

### b. Remove Email and Phone Fields

Next, you'll remove the fields to update email and phone number from the profile page.

In `src/app/[countryCode]/(main)/account/@dashboard/profile/page.tsx`, remove the following lines from the `return` statement:

```tsx title="src/app/[countryCode]/(main)/account/@dashboard/profile/page.tsx" badgeLabel="Storefront" badgeColor="blue"
<Divider />
<ProfileEmail customer={customer} />
<Divider />
<ProfilePhone customer={customer} />
```

If you go to your profile page and click on "Profile" in the sidebar, the email and phone number fields will be removed.

![Profile page without email and phone fields](https://res.cloudinary.com/dza7lstvk/image/upload/v1747740515/Medusa%20Resources/CleanShot_2025-05-20_at_14.28.09_2x_ugab7d.png)

### c. Disable Phone Updates in Medusa

While removing the email and phone fields from the profile page prevents customers using the storefront from updating their phone number, it doesn't prevent them from updating it using Medusa's API.

In this section, you'll add a [middleware](!docs!/learn/fundamentals/api-routes/middlewares) to the `/store/customers/me` API route to prevent customers from updating their phone number.

A middleware is a function that's executed whenever a request is sent to an API route. It's executed before the route handler, allowing you to validate requests, apply authentication guards, and more.

<Note>

Learn more in the [Middlewares](!docs!/learn/fundamentals/api-routes/middlewares) documentation.

</Note>

To add a middleware, in your Medusa application, create the file `src/api/middlewares.ts` with the following content:

```ts title="src/api/middlewares.ts" badgeLabel="Medusa Application" badgeColor="green"
import { defineMiddlewares } from "@medusajs/framework/http";

export default defineMiddlewares({
  routes: [
    {
      matcher: "/store/customers/me",
      method: ["POST"],
      middlewares: [
        async (req, res, next) => {
          const { phone } = req.body as Record<string, string>

          if (phone) {
            return res.status(400).json({
              error: "Phone number is not allowed to be updated"
            })
          }

          next()
        }
      ]
    }
  ]
})
```

You define middlewares using the `defineMiddlewares` function. It accepts an object having a `routes` property that holds all middlewares applied to API routes.

Each object in `routes` has the following properties:

- `matcher`: The API route to apply the middleware to. You apply it to the `/store/customers/me` route.
- `method`: The HTTP method to apply the middleware to. You set it to `POST` so that the middleware is applied only tp `POST` requests to the `/store/customers/me` route.
- `middlewares`: An array of middlewares to apply to the route. You add a middleware that throws an error if the request body contains a `phone` property. This prevents customers from updating their phone number using the API.

Any `POST` request to the `/store/customers/me` route will now be validated to ensure they're not updating the phone number.

---

## Next Steps

You've now implemented phone authentication in Medusa with Twilio SMS integration.

### Authenticate Other Actor Types

This tutorial focused on authenticating customers using their phone number. However, you can also authenticate other actor types, such as admin users and vendors.

To do that, first, enable the `phone-auth` authentication strategy in `medusa-config.js` for the actor types. For example:

```ts title="medusa-config.js"
module.exports = defineConfig({
  projectConfig: {
    // ...
    http: {
      // ...
      authMethodsPerActor: {
        user: ["emailpass", "phone-auth"],
        customer: ["emailpass", "phone-auth"],
        vendor: ["emailpass", "phone-auth"],
      },
    },
  },
})
```

Then, when sending requests to the authentication API routes mentioned in the [Test Out Phone Authentication](#test-out-phone-authentication) section, replace `customer` with the actor type you want to authenticate:

- `/auth/customer/phone-auth/register` -> `/auth/user/phone-auth/register`
- `/auth/customer/phone-auth` -> `/auth/user/phone-auth`
- `/auth/customer/phone-auth/callback` -> `/auth/user/phone-auth/callback`

Finally, update the UI to show the phone authentication option for the actor type you want to authenticate. This depends on the UI you're using, but you can follow a similar approach to the Next.js Starter Storefront customizations.

<Note>

The login form of Medusa Admin can't be customized, so you'll have to build a custom admin dashboard to support phone authentication.

</Note>

### Learn More about Medusa

If you're new to Medusa, check out the [main documentation](!docs!/learn), where you'll get a more in-depth learning of all the concepts you've used in this guide and more.

To learn more about the commerce features that Medusa provides, check out Medusa's [Commerce Modules](../../../commerce-modules/page.mdx).

### Troubleshooting

If you encounter issues during your development, check out the [troubleshooting guides](../../../troubleshooting/page.mdx).

### Getting Help

If you encounter issues not covered in the troubleshooting guides:

1. Visit the [Medusa GitHub repository](https://github.com/medusajs/medusa) to report issues or ask questions.
2. Join the [Medusa Discord community](https://discord.gg/medusajs) for real-time support from community members.
3. Contact the [sales team](https://medusajs.com/contact/) to get help from the Medusa team.
