---
tags:
  - customer
  - storefront
  - auth
---

import { Prerequisites, CodeTabs, CodeTab, Details } from "docs-ui"

export const metadata = {
  title: `Third-Party or Social Login in Storefront`,
}

# {metadata.title}

In this guide, you'll learn how to implement third-party or social login in your storefront. You'll implement the flow using Google as an example.

## Third-Party Login Flow in Storefront

Assuming you already set up the [Auth Module Provider](../../../commerce-modules/auth/auth-providers/page.mdx) in your Medusa application, you can login a customer with a third-party service, such as Google or GitHub, using the following flow:

![Diagram illustrating the authentication flow between the storefront, Medusa application, and the third-party service.](https://res.cloudinary.com/dza7lstvk/image/upload/v1725531068/Medusa%20Resources/Social_Media_Graphics_third-party-auth-customer_kfn3k3.jpg)

1. Authenticate the customer with the [Authenticate Customer API route](!api!/store#auth_postactor_typeauth_provider).
2. The auth route returns a URL to authenticate with third-party service, such as login with Google. The storefront, when it receives a `location` property in the response, must redirect to the returned location.
3. Once the authentication with the third-party service finishes, it redirects back to the storefront with query parameters such as `code` and `state`. So, make sure your third-party service is configured to redirect to your storefront page after successful authentication.
4. The storefront sends a request to the [Validate Authentication Callback API route](!api!/store#auth_postactor_typeauth_providercallback) passing the query parameters received from the third-party service.
5. If the callback validation is successful, the storefront receives the authentication token.
6. Decode the received token in the frontend using tools like [react-jwt](https://www.npmjs.com/package/react-jwt).
    - If the decoded data has an `actor_id` property, then the user is already registered. So, use this token for subsequent authenticated requests.
    - If not, follow the rest of the steps.
7. The storefront uses the authentication token to create the customer using the [Create Customer API route](!api!/store#customers_postcustomers).
8. The storefront sends a request to the [Refresh Token Route](#add-the-function-to-refresh-the-token) to retrieve a new token for the customer.

You'll implement the flow in this guide using Google as an example.

<Prerequisites
  items={[
    {
      text: "Install the Google Auth Module Provider in your Medusa application, or follow along the same steps with the provider you're using.",
      link: "/commerce-modules/auth/auth-providers/google"
    }
  ]}
/>

## JS SDK Authentication Configuration

Before implementing the third-party login flow, you need to configure in the JS SDK the authentication method you're using in your storefront. This defines how the JS SDK will handle sending authenticated requests after the customer is authenticated.

Learn more about the authentication methods and how to configure them in the [Login Customer](../login/page.mdx) guide.

---

## Step 1: Authenticate Customer in Medusa

When the customer clicks on a "Login with Google" button, send a request to the [Authenticate Customer API route](!api!/store#auth_postactor_typeauth_provider).

For example:

<Note title="Tip">

Learn how to install and configure the JS SDK in the [JS SDK documentation](../../../js-sdk/page.mdx).

</Note>

<CodeTabs group="authenticated-request">
  <CodeTab label="React" value="react">
  
export const reactHighlights = [
  ["7", "login", "Send a request to the Authenticate Customer API route"],
  ["9", "result.location", "If the request returns a location, redirect to that location to continue the authentication."],
  ["16", "", "If the token isn't returned, the authentication has failed."],
  ["24", "setToken", "Set the token in the client to be used in subsequent requests."],
  ["27", "retrieve", "Retrieve the customer's details as an example of testing authentication."]
]

```tsx highlights={reactHighlights}
"use client" // include with Next.js 13+

import { sdk } from "@/lib/sdk"

export default function Login() {
  const loginWithGoogle = async () => {
    const result = await sdk.auth.login("customer", "google", {})

    if (typeof result === "object" && result.location) {
      // redirect to Google for authentication
      window.location.href = result.location

      return
    }
    
    if (typeof result !== "string") {
      // result failed, show an error
      alert("Authentication failed")
      return
    }

    // authentication successful
    // set the token in the client to be used in subsequent requests
    sdk.client.setToken(result)

    // retrieve the customer using the token
    const { customer } = await sdk.store.customer.retrieve()

    console.log(customer)
  }

  return (
    <div>
      <button onClick={loginWithGoogle}>Login with Google</button>
    </div>
  )
}
```

  </CodeTab>
  <CodeTab label="JS SDK" value="js-sdk">
  
export const jsSdkHighlights = [
  ["2", "login", "Send a request to the Authenticate Customer API route"],
  ["4", "", "If the request returns a location, redirect to that location to continue the authentication."],
  ["11", "", "If the token isn't returned, the authentication has failed."],
  ["19", "setToken", "Set the token in the client to be used in subsequent requests."],
  ["22", "retrieve", "Retrieve the customer's details as an example of testing authentication."]
]

```ts highlights={jsSdkHighlights}
const loginWithGoogle = async () => {
  const result = await sdk.auth.login("customer", "google", {})

  if (typeof result === "object" && result.location) {
    // redirect to Google for authentication
    window.location.href = result.location

    return
  }
  
  if (typeof result !== "string") {
    // result failed, show an error
    alert("Authentication failed")
    return
  }

  // authentication successful
  // set the token in the client to be used in subsequent requests
  sdk.client.setToken(result)

  // retrieve the customer using the token
  const { customer } = await sdk.store.customer.retrieve()

  console.log(customer)
}
```

  </CodeTab>
</CodeTabs>

You define a `loginWithGoogle` function that:

- Sends a request to the `/auth/customer/google` API route.
- If the response is an object with a `location` property, then you redirect to the returned page for authentication with the third-party service.
- If the response is a string, then the customer has been authenticated before. You can use the token for subsequent authenticated request.
- To use the token for subsequent authenticated request, you must set it in the JS SDK using the `client.setToken` method.
- Now, subsequent requests are authenticated. As an example, you can retrieve the customer's details using the `store.customer.retrieve` method.

<Note title="Tip">

If you're using a provider other than Google, or if you've configured the Google provider with an ID other than `google`, replace `google` in the parameter `login("customer", "google", {})` with your provider ID.

</Note>

---

## Step 2: Callback Page in Storefront

In the previous step, you implemented as part of the login flow redirecting the customer to the third-party service for authentication.

Once the customer authenticates with the third-party service, the service redirects the customer back to your storefront with query parameters such as `code` and `state`.

The next step is to create the page in your storefront that the customer is redirected to after they authenticate with Google. You'll use this page's URL as the Redirect Uri in your Google settings, and set it in the `callbackUrl` of your [Google Auth Module Provider](../../../commerce-modules/auth/auth-providers/google/page.mdx)'s configurations.

<Note title="Tip">

The callback page is implemented step-by-step to explain the different parts of the flow. You can copy the full page code in the [Full Code Example for Third-Party Login Callback Page](#full-code-example-for-third-party-login-callback-page) section, and then add the functions one by one to test the flow.

</Note>

### Install the React-JWT Library

First, install the [react-jwt library](https://www.npmjs.com/package/react-jwt) in your storefront to use it for decoding the token received from Google:

```bash npm2yarn
npm install react-jwt
```

### Implement the Callback Page

Then, in a new page in your storefront that will be used as the callback / redirect uri destination, add the following:

<CodeTabs group="authenticated-request">
  <CodeTab label="React" value="react">
  
export const sendCallbackReactHighlights = [
  ["12", "queryParams", "The query parameters received from Google, such as `code` and `state`."],
  ["21", "callback", "Send a request to the Validate Authentication Callback API route"],
  ["28", "catch", "If an error occurs, show an alert and exit execution."],
  ["36", "setToken", "Set the token in the client to be used in subsequent requests."]
]

```tsx highlights={sendCallbackReactHighlights}
"use client" // include with Next.js 13+

import { HttpTypes } from "@medusajs/types"
import { useEffect, useMemo, useState } from "react"
import { decodeToken } from "react-jwt"
import { sdk } from "@/lib/sdk"

export default function GoogleCallback() {
  const [loading, setLoading] = useState(true)
  const [customer, setCustomer] = useState<HttpTypes.StoreCustomer>()
  // for other than Next.js
  const queryParams = useMemo(() => {
    const searchParams = new URLSearchParams(window.location.search)
    return Object.fromEntries(searchParams.entries())
  }, [])

  const sendCallback = async () => {
    let token = ""

    try {
      token = await sdk.auth.callback(
        "customer", 
        "google", 
        // pass all query parameters received from the
        // third party provider
        queryParams
      )
    } catch (error) {
      alert("Authentication Failed")
      
      throw error
    }

    // set the token in the client
    // to be used in subsequent requests
    sdk.client.setToken(token)

    return token
  }

  // TODO add more functions

  return (
    <div>
      {loading && <span>Loading...</span>}
      {customer && <span>Created customer {customer.email} with Google.</span>}
    </div>
  )
}
```

  </CodeTab>
  <CodeTab label="JS SDK" value="js-sdk">
  
export const sendCallbackFetchHighlights = [
  ["6", "queryParams", "The query parameters received from Google, such as `code` and `state`."],
  ["12", "callback", "Send a request to the Validate Authentication Callback API route"],
  ["19", "catch", "If an error occurs, show an alert and exit execution."],
  ["27", "setToken", "Set the token in the client to be used in subsequent requests."]
]

```ts highlights={sendCallbackFetchHighlights}
import { decodeToken } from "react-jwt"

// ...

const searchParams = new URLSearchParams(window.location.search)
const queryParams = Object.fromEntries(searchParams.entries())

const sendCallback = async () => {
  let token = ""

  try {
    token = await sdk.auth.callback(
      "customer", 
      "google", 
      // pass all query parameters received from the
      // third party provider
      queryParams
    )
  } catch (error) {
    alert("Authentication Failed")
    
    throw error
  }

  // set the token in the client
  // to be used in subsequent requests
  sdk.client.setToken(token)

  return token
}

// TODO add more functions...
```

  </CodeTab>
</CodeTabs>

This adds in the new page the function `sendCallback` which sends a request to the [Validate Callback API route](!api!/store#auth_postactor_typeauth_providercallback), passing it all query parameters received from Google. Those include the `code` and `state` parameters.

After that, you set the token in the JS SDK using the `client.setToken` method. This ensures that the token is passed to subsequent requests, such as the request to create the customer.

### Add the Function to Create a Customer

Next, replace the `TODO` after the `sendCallback` function with the following:
  
export const createCustomerHighlights = [
  ["3", "create", "Create a customer"]
]

```ts highlights={createCustomerHighlights} title="JS SDK / React Applicable"
const createCustomer = async () => {
  // create customer
  await sdk.store.customer.create({
    email: "example@medusajs.com",
  })
}

// TODO add more functions...
```

This adds to the page the function `createCustomer` which creates a customer if this is the first time the customer is authenticating with the third-party service.

Notice that this method assumes that the token received from the [Validate Callback API route](!api!/store#auth_postactor_typeauth_providercallback) is already set in the JS SDK, as done at the end of the `sendCallback` function. So, if you're implemeting this flow without using the JS SDK, make sure to pass the token in the authorization Bearer header.

### Add the Function to Refresh the Token

Next, replace the new `TODO` with the following:
  
export const refreshTokenHighlights = [
  ["3", "refresh", "Fetch a new token for the created customer."]
]

```ts highlights={refreshTokenHighlights} title="JS SDK / React Applicable"
const refreshToken = async () => {
  // refresh the token
  const result = await sdk.auth.refresh()
  
  // set the new token
  sdk.client.setToken(result)
}

// TODO add more functions...
```

This adds to the page the function `refreshToken` which is used after the new customer is created to refresh their authentication token. This ensures that the authentication token includes the details of the created customer.

Notice that this method assumes that the token received from the [Validate Callback API route](!api!/store#auth_postactor_typeauth_providercallback) is already set in the JS SDK, as done at the end of the `sendCallback` function. So, if you're implemeting this flow without using the JS SDK, make sure to pass the token in the authorization Bearer header.

Then, this method also sets the new token in the JS SDK to be used in subsequent authenticated requests.

### Add the Function to Validate the Callback

Finally, add in the place of the new `TODO` the `validateCallback` function that runs when the page first loads to validate the authentication:

<CodeTabs group="authenticated-request">
  <CodeTab label="React" value="react">
  
export const validateReactHighlights = [
  ["2", "sendCallback", "Validate the callback in Medusa and retrieve the authentication token"],
  ["4", "shouldCreateCustomer", "Check if the decoded token has an `actor_id` property to decide whether a customer to be created."],
  ["7", "createCustomer", "Create a customer if the decoded token doesn't have `actor_id`."],
  ["9", "refreshToken", "Fetch a new token for the created customer."],
  ["13", "retrieve", "Retrieve the customer's details as an example of testing authentication."]
]

```tsx highlights={validateReactHighlights}
const validateCallback = async () => {
  const token = await sendCallback()

  const shouldCreateCustomer = (decodeToken(token) as { actor_id: string }).actor_id === ""

  if (shouldCreateCustomer) {
    await createCustomer()

    await refreshToken()
  }

  // use token to send authenticated requests
  const { customer: customerData } =  await sdk.store.customer.retrieve()

  setCustomer(customerData)
  setLoading(false)
}


useEffect(() => {
  if (!loading) {
    return
  }

  validateCallback()
}, [loading])
```

  </CodeTab>
  <CodeTab label="JS SDK" value="js-sdk">
  
export const validateFetchHighlights = [
  ["2", "sendCallback", "Validate the callback in Medusa and retrieve the authentication token"],
  ["4", "shouldCreateCustomer", "Check if the decoded token has an `actor_id` property to decide whether a customer to be created."],
  ["7", "createCustomer", "Create a customer if the decoded token doesn't have `actor_id`."],
  ["9", "refreshToken", "Fetch a new token for the created customer."],
  ["13", "retrieve", "Retrieve the customer's details as an example of testing authentication."]
]

```ts highlights={validateFetchHighlights}
const validateCallback = async () => {
  const token = await sendCallback()

  const shouldCreateCustomer = (decodeToken(token) as { actor_id: string }).actor_id === ""

  if (shouldCreateCustomer) {
    await createCustomer()

    await refreshToken()
  }

  // use token to send authenticated requests
  const { customer: customerData } =  await sdk.store.customer.retrieve()

  setCustomer(customerData)
  setLoading(false)
}
```

  </CodeTab>
</CodeTabs>

The `validateCallback` function uses the functions added earlier to:

1. Send a request to the [Validate Callback API route](!api!/store#auth_postactor_typeauth_providercallback), which returns an authentication token.
    - The `sendCallback` function also sets the token in the JS SDK to be passed in subsequent requests.
2. Decodes the token to check if it has an `actor_id` property.
  - If so, then the customer is previously registered, and the authentication token can be used for subsequent authenticated requests.
  - If not, this is the first time the customer is authenticating with the third-party service, so:
      1. Create a customer using the [Create Customer API route](!api!/store#customers_postcustomers).
      2. Refetch the customer's authentication token after it's created using the [Refresh Token API route](!api!/store#auth_postactor_typeauth_providerrefresh).
      3. Use the token for subsequent authenticated requests.
3. Retrieve the customer's details as an example of testing authentication.

The customer is now authenticated, and you can redirect them to the home page or the page they were trying to access before logging in.

### Full Code Example for Third-Party Login Callback Page

<CodeTabs group="authenticated-request">
  <CodeTab label="JS SDK" value="js-sdk">

```ts
import { decodeToken } from "react-jwt"

// ...

const queryParams = new URLSearchParams(window.location.search)
const code = queryParams.get("code")
const state = queryParams.get("state")


const sendCallback = async () => {
  let token = ""

  try {
    token = await sdk.auth.callback(
      "customer", 
      "google", 
      // pass all query parameters received from the
      // third party provider
      queryParams
    )
  } catch (error) {
    alert("Authentication Failed")
    
    throw error
  }

  // set the token in the client
  // to be used in subsequent requests
  sdk.client.setToken(token)

  return token
}

const createCustomer = async () => {
  // create customer
  await sdk.store.customer.create({
    email: "example@medusajs.com",
  })
}

const refreshToken = async () => {
  // refresh the token
  const result = await sdk.auth.refresh()
  
  // set the new token
  sdk.client.setToken(result)
}

const validateCallback = async () => {
  const token = await sendCallback()

  const shouldCreateCustomer = (decodeToken(token) as { actor_id: string }).actor_id === ""

  if (shouldCreateCustomer) {
    await createCustomer()

    await refreshToken()
  }

  // use token to send authenticated requests
  const { customer: customerData } =  await sdk.store.customer.retrieve()

  setCustomer(customerData)
  setLoading(false)
}
```

  </CodeTab>
  <CodeTab label="React" value="react">

```tsx
"use client" // include with Next.js 13+

import { HttpTypes } from "@medusajs/types"
import { useEffect, useMemo, useState } from "react"
import { decodeToken } from "react-jwt"
import { sdk } from "@/lib/sdk"

export default function GoogleCallback() {
  const [loading, setLoading] = useState(true)
  const [customer, setCustomer] = useState<HttpTypes.StoreCustomer>()
  // for other than Next.js
  const queryParams = useMemo(() => {
    const searchParams = new URLSearchParams(window.location.search)
    return Object.fromEntries(searchParams.entries())
  }, [])

  const sendCallback = async () => {
    let token = ""

    try {
      token = await sdk.auth.callback(
        "customer", 
        "google", 
        // pass all query parameters received from the
        // third party provider
        queryParams
      )
    } catch (error) {
      alert("Authentication Failed")
      
      throw error
    }

    // set the token in the client
    // to be used in subsequent requests
    sdk.client.setToken(token)

    return token
  }

  const createCustomer = async () => {
    // create customer
    await sdk.store.customer.create({
      email: "example@medusajs.com",
    })
  }

  const refreshToken = async () => {
    // refresh the token
    const result = await sdk.auth.refresh()
    
    // set the new token
    sdk.client.setToken(result)
  }

  const validateCallback = async () => {
    const token = await sendCallback()

    const shouldCreateCustomer = (decodeToken(token) as { actor_id: string }).actor_id === ""

    if (shouldCreateCustomer) {
      await createCustomer()

      await refreshToken()
    }

    // use token to send authenticated requests
    const { customer: customerData } =  await sdk.store.customer.retrieve()

    setCustomer(customerData)
    setLoading(false)
  }

  useEffect(() => {
    if (!loading) {
      return
    }

    validateCallback()
  }, [loading])

  return (
    <div>
      {loading && <span>Loading...</span>}
      {customer && <span>Created customer {customer.email} with Google.</span>}
    </div>
  )
}
```

  </CodeTab>
</CodeTabs>
